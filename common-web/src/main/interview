一、Java基础
基础部分 
Java Collections相关，主要是List,Set,Map和Queue
   List:一个接口，不能实例化，需要实例化一个ArrayList(实现动态数组)， Vector（实现动态数组） ，LinkedList（实现链表）， Stack（实现堆栈）
	Set:无序，不重复元素。HashSet按Hash算法来存储集合的元素，因此具有很好的存取和查找性能。 
		HashSet的特点：（1）HashSet不是同步的，多个线程访问是需要通过代码保证同步，（2）集合元素值可以使null。存取速度比较快 
		TreeSet ：TreeSet类实现了SortedSet接口，能够对集合中的对象进行排序。 
	Map:
		HashMap:Map 是一种把键对象和值对象映射的集合，它的每一个元素都包含一对键对象和值对象,key与value均可为空，线程非安全
		Hashtable:线程安全，key不允许为空。内部使用synchronized
		LinkedHashMap: LinkedHashMap是Map接口的哈希表和链接列表实现，具有可预知的迭代顺序。此实现提供所有可选的映射操作，并允许使用null值和null键。此类不保证映射的顺序，特别是它不保证该顺序恒久不变。
		TreeMap:基于红黑树实现。TreeMap没有调优选项，因为该树总处于平衡状态。适用于在Map中插入、删除和定位元素。适用于按自然顺序或自定义顺序遍历键（key）。
		ConcurrentHashMap(重要):ConcurrentHashMap允许多个修改操作并发进行，其关键在于使用了锁分离技术。它使用了多个锁来控制对hash表的不同部分进行的修改。ConcurrentHashMap内部使用段(Segment)来表示这些不同的部分，每个段其实就是一个小的hash table，它们有自己的锁。只要多个修改操作发生在不同的段上，它们就可以并发进行。
					有些方法需要跨段，比如size()和containsValue()，它们可能需要锁定整个表而而不仅仅是某个段，这需要按顺序锁定所有段，操作完毕后，又按顺序释放所有段的锁。这里“按顺序”是很重要的，否则极有可能出现死锁，在ConcurrentHashMap内部，段数组是final的，并且其成员变量实际上也是final的，但是，仅仅是将数组声明为final的并不保证数组成员也是final的，这需要实现上的保证。这可以确保不会出现死锁，因为获得锁的顺序是固定的。
	
	Queue:(有待掌握)阻塞队列的典型例子是BlockingQueue，非阻塞队列的典型例子是ConcurrentLinkedQueue
			await方法指：造成当前线程在接到信号或被中断之前一直处于等待状态。
			signal方法指：唤醒一个等待线程。
[2] 了解的常用实现及其用法（能按照需要使用ArrayList和LinkedList,HashSet和HashMap的特性,在什么情况下使用过Queue）
 		创建索引的时候即有使用Queue.
[3] 了解线程安全的实现，有使用经验（比如用过CopyOnWriteList,ConcurrentHashMap和ConcurrentLinkedQueue以及为什么要用它）
 		CopyOnWriteArrayList适合使用在读操作远远大于写操作的场景里，比如缓存。
		在你的应用中有一个列表（List），它被频繁的遍历，但是很少被修改。像“你的主页上的前十个分类，它被频繁的访问，但是每个小时通过Quartz的Job来调度更新”。
		如果你使用ArrayList来作为该列表的数据结构并且不使用同步（synchronization），你可能会遇到ConcurrentModificationException，
		因为在你使用Quartz的Job修改该列表时，其他的代码可能正在遍历该列表。 当多线程同时访问某一对象时，可以考虑new一个该对象，再将这个对象放到new的这个对象中，即是应用了copyOnWrite原理。
		CopyOnWriteArrayList的另一个使用案例是观察者设计模式。如果事件监听器由多个不同的线程添加和移除，那么使用CopyOnWriteArrayList将会使得正确性和简单性得以保证。
		
		ConcurrentHashMap和Hashtable主要区别就是围绕着锁的粒度以及如何锁。
		
[4] 能大概说出线程安全的集合类的具体实现方法（比如CopyOnWriteList,ConcurrentHashMap和ConcurrentLinkedQueue的实现）
 
[5] 在源码层面上研究过类的实现（比如看过jdk6里的CopyOnWriteList,ConcurrentHashMap和ConcurrentLinkedQueue的代码，看过一部分，能说出一点就行）
 
Java内存模型
 
[2] 知道volatile怎么用，Atomic类的用法
 
[3] CAS是什么；能写出用double check locking实现的线程安全的单例
 	public class Singleton {
	private Singleton() {
	}

	public static Singleton getInstance() {
		return Nested.instance;
	}
	// 在第一次被引用时被加载
	static class Nested {
		private static Singleton instance = new Singleton();
	}
	public static void main(String args[]) {
		Singleton instance = Singleton.getInstance();
		Singleton instance2 = Singleton.getInstance();
		System.out.println(instance == instance2);
	}
	}
	
	public class Singleton{  
       private static volatile Singleton instance = null;
       private Singleton(){}  
       public static Singleton getInstance(){  
           if(instance == null){  
               //双重检查加锁，只有在第一次实例化时，才启用同步机制，提高了性能。  
               synchronized(Singleton.Class){  
                   if(instance == null){  
                       instance = new Singleton();  
                   }  
               }  
           }  
           return instance;  
       }  
    }  

[4] 了解happen-before规则（能利用此规则分析代码是否线程安全）
 		Happens-before 关系
		happens-before 关系保证：如果线程 A 与线程 B 满足 happens-before 关系，则线程 A 执行动作的结果对于线程 B 是可见的。如果两个操作未按 happens-before 排序，JVM 将可以对他们任意重排序。
		下面介绍几个与理解 ConcurrentHashMap 有关的 happens-before 关系法则：
    程序次序法则：如果在程序中，所有动作 A 出现在动作 B 之前，则线程中的每动作 A 都 happens-before 于该线程中的每一个动作 B。
    监视器锁法则：对一个监视器的解锁 happens-before 于每个后续对同一监视器的加锁。
    Volatile 变量法则：对 Volatile 域的写入操作 happens-before 于每个后续对同一 Volatile 的读操作。
    传递性：如果 A happens-before 于 B，且 B happens-before C，则 A happens-before C。
	
[5] 了解Java里的类是怎么保存的。Object的头部都有什么。什么是false-sharing，最好举例，如果研究过LMAX的disruptor更好
 	
Java多线程开发
 
[2] 基本的锁synchronized, Lock, Condition的用法。ThreadLocal的实现（Map）
 	
[3] 了解线程池参数意义；知道怎么分析线程异常的情况（例如cpu占用过高，可利用top命令找出线程id，再利用jstack定位stacktrace）
 	
[4] 了解其他线程同步的类的用法，比如CountdownLatch，Exchanger，Barrier，Semaphore等
 	
[5] 知道怎么用wait和notify来控制线程同步（java monitor基础）；了解AbstractQueuedSynchronizer原理
 	synchronized(obj) {
    while(!condition) {
        obj.wait();
    }
    obj.doSomething();
	}
	当线程A获得了obj锁后，发现条件condition不满足，无法继续下一处理，于是线程A就wait()。
	在另一线程B中，如果B更改了某些条件，使得线程A的condition条件满足了，就可以唤醒线程A：
	synchronized(obj) {
    condition = true;
    obj.notify();
	}
JVM
 
[2] jdk6的hotspot堆的结构。了解两个survivor区
 
[3] 了解常用GC算法的特点，能讲清楚CMS算法的过程，有根据不同应用程序调优jvm参数的经验（比如对于网络程序，知道调整survivor ratio的大小）
 
[4] 熟悉常用GC算法的应用场景及优缺点，能根据不同的需求进行选型
 
[5] 了解垃圾回收生命周期，具体可考察Strong, Soft, Weak和Phantom引用的区别，以及都有什么作用（主要区别在于被GC的时间不同。Soft比Weak更不eager被GC。Weak和Phantom的区别在于入ReferenceQueue的时候不同）；或者知道线程safepoint，能指出哪些执行语句能达到safepoint
 
网络
 
[2] 对http 协议有一定熟悉，知道get与post的区别，对http的header常见参数了解一些
 
[3] 知道socket的用法。对于nio，知道怎么用socket.select和socket.accept写出一个基本的socket服务（大概伪代码写出来就行）
 
[4] 如果用过Netty，能说出netty的基本概念（事件驱动，channel的几种状态，channel pipeline等。如果熟悉netty3，了解boss和worker；如果熟悉netty4，了解eventloop）；如果没用过netty，说说用过的网络IO框架
 
[5] 了解常见io模型：bio，nio，aio,对tcp调优有经验，或者有c100k规模的网络程序的开发经验
 
开源框架相关
 
[2] 能说出使用过的开源框架的概念和原理，和一些经验
 
[4] 看过开源框架的代码
 
[5] 自己有开源框架或者深度参与过
 
其他
 
[2] 对jdk 源码看过部分类的实现 如String, HashMap等
 
[3] 能列举出一些常用的设计模式在生产中的一些应用场景
 
[4] java里类加载的机制（能说出delegate或者双亲委派就行）；了解String pool；Integer -128~128的缓存
 
[5] 对java 虚拟机规范以及java 语言特性有深入了解
 	
二、服务器相关
 
LINUX
 
[2] 熟练使用tail、less等。
 	less 比more更强大，可以使用 PgUp,PgDn来上下翻页。
[3] 熟练使用grep、find、sed、awk等基本用法。了解文件权限规则。
 		sed:管道命令，主要是以行为单位进行处理，可以将数据行进行替换、删除、新增、选取等特定工作
			sed '1d' xxx.log              #删除第一行 
			sed -n '1p' xxx.log           #显示第一行 
			sed -i '$a bye' xxx.log         #在文件ab中最后一行直接输入"bye"
  awk:AWK是一种处理文本文件的语言，是一个强大的文本分析工具。
	
[4] 编写过功能相对复杂的shell 脚本，例如 日志处理，启动shell脚本等
 	
三、存储
 	
存储
 
[2] 了解mongodb、mysql、redis、hbase 使用方式，大概知道相关存储的一些使用场景
 		HBase不同于一般的关系数据库，它是一个适合于非结构化数据存储的数据库。另一个不同的是HBase基于列的而不是基于行的模式。
[3] 对redis 存储方式aof、rdb等有一些了解，熟悉mysql读写分离、一主多从等架构方式，对常用mysql proxy 选型有一定了解。
 		RDB 持久化可以在指定的时间间隔内生成数据集的时间点快照（point-in-time snapshot）。
	AOF 持久化记录服务器执行的所有写操作命令，并在服务器启动时，通过重新执行这些命令来还原数据集
	两种区别就是，一个是持续的用日志记录写操作，crash后利用日志恢复；一个是平时写操作的时候不触发写，只有手动提交save命令，或者是关闭命令时，才触发备份操作。
	选择的标准，就是看系统是愿意牺牲一些性能，换取更高的缓存一致性（aof），还是愿意写操作频繁的时候，不启用备份来换取更高的性能，待手动运行save的时候，再做备份（rdb）。
	rdb这个就更有些 eventually consistent的意思了。
	mysql读写分离:1.物理服务器增加，负荷增加,2.主从只负责各自的写和读，极大程度的缓解X锁和S锁争用,3.从库可配置myisam引擎，提升查询性能以及节约系统开销
		4.从库同步主库的数据和主库直接写还是有区别的，通过主库发送来的binlog恢复数据，但是，最重要区别在于主库向从库发送binlog是异步的，从库恢复数据也是异步的
		5.读写分离适用与读远大于写的场景，如果只有一台服务器，当select很多时，update和delete会被这些select访问中的数据堵塞，等待select结束，并发性能不高。
		对于写和读比例相近的应用，应该部署双主相互复制
[4] 对分布式存储集群有一定了解，对b+tree, LSM 等存储方式有一定了解，能列出常见mysql、redis、hbase、mongo存储的利弊
		Redis定位在"快"，HBase定位于"大",mongodb定位在"灵活.
		
1、spring的缓存,mybatis缓存
2、介绍下dubbo。A服务调用B服务，B服务又调用C服务,这种情况怎么办
3、JVM监控工具有哪些，区别又是什么（如能追上各个命令的使用监控，显得更好）,如何调优的（就那么几个内存参数和GC参数什么时候配置什么样的）?如何定位问题的？（就说各种命令，gc日志，快照，监控工具）
4、使用过Solr?说说（有面试特意想听从luence发展而来的可独立部署）
5、用过哪些MQ,各个MQ的区别不同点在哪(阿里还问了协议；采用哪种语言开发的也说说比较好，因为一些面试为了好跟踪问题确实考虑了这一方面)，总之，多说为益，再就是apache新一代推出的MQ：apollo说说完全是加分项阿里面试者也不知道。
6、根据你做过的东西，让你说说某一功能或者模块
	blackDragonList内存优化，以前存储到mongo中，现在全部存储到这个List集合中，才有黑名单方式，将无货的地区纳入到黑名单，减少内存占用，效果为一个数量级减少。
7、java8了解过吗（阿里问的，时间API,集合的处理，lambda怎么用的说说,函数式编程，很多集合底层代码都有变动能详细说出来加分如hashMap，集合底层代码变动网上是没有的别查了，看JDK7,8,9源码就行）（本人建议最好把JDK7，8，将要推出的9各种新特点熟记并全部动手编写下，9暂时不能编写呢），JDK9特性说上绝逼加分，他也很可能不知道，再就是CMS+新生代并行收集器JAVA8不建议使用了（很少有面试官知道），java9淘汰掉了还有永生带被元空间代替即使阿里他也不知道绝逼加分。
		函数式编程：把一段函数当作是一个参数来进行传递，所谓"第一等公民"（first class），指的是函数与其他数据类型一样，处于平等地位，
		可以赋值给其他变量，也可以作为参数，传入另一个函数，或者作为别的函数的返回值。
		
8、说说memcached(直接上原理，说分配的过程，再说注意点优缺点，和哈希一致算法能联系起来更好，前提一致算法要理解要能用代码实现，否则面试着好追问，你要不懂到起反作用了)
		Hash 一致性算法(学习并掌握)
9、有几种锁，各个区别，多说有益，多说上底层的更好，阿里还问了原理
		1、自旋锁,2、自旋锁的其他种类,3、阻塞锁,4、可重入锁,5、读写锁,6、互斥锁,7、悲观锁,8、乐观锁,9、公平锁,10、非公平锁,11、偏向锁,12、对象锁,
		13、线程锁,14、锁粗化,15、轻量级锁,16、锁消除,17、锁膨胀,18、信号量
		自旋锁：
		读写锁：
		互斥锁：
		悲观锁：
		偏向锁：
		线程锁：
		ReentrantLock类实现了Lock它拥有与ynchronized相同的并发性和内存语义，但是添加了类似 锁投票、定时锁等候和可中断锁等候 的一些特性，此外它还提供了在激烈争用情况下更佳的性能。
	定时锁等候： 设置定时等候之后，在这个等候时间内如果没有获得这个锁，这个线程就会自己中断。可中断锁等候： 就是线程等候可以自己中断也可以别人中断。
10、sleep和await()的区别（补充上condition给自己加分）
		
11、线程池说说几种（最好搞懂源码里的原理起码用的哪些队列能说说各自的使用场景说说都是加分的地方，有什么注意点，什么keepalivatime其他的什么的细的问题，多多益善）
12、哪些锁，不同的地方在哪（说的越多越详细越深越好）
13、Threadlocal，上来说原理，再举个例子用用哪些情况为益
14、线程池线程池如何解决死锁问题如何诊断，一定要说上具体命令如何定位阿里还特意追问的（从避免这种情况出发说如定时锁，锁粒度等再谈一些监控工具和命令，诊断啥的都会是加分）
15、常见的序列化方式（面试官想让你说hession，多说为益）
16、mysql与mongoDB如何选型，什么时候用谁
17、A,B两个线程同时启动，但让A结束后B在结束，如何实现（多种，多说为益，他想问join,其他很多方式一些面试官都不知道绝对加分）
18、redis中wacth之后，之后有事务提交未执行，返回信息吗，返回什么
19、memcached和redis的区别，很多，把重点说出来，及各自优缺点，从原理上分析对比必是加分项可能redis原理他不懂的，几乎家家公司必问
20、mongoDB的干什么的（在说说内存文件映射引擎，持久化的2个过程必是加分项）
21、python了解吗，主要用来做什么，实现爬虫能实现吗（爬虫技术知道的话多扯些有益而无害）
22、JVM的各个带说说（说的越详细越好各个参数都说上什么情况下怎么设置参数更好，和GC结合起来必加分），JVM的GC为什么选择分带收集（最好各个算法说上，为什么这个带使用这个，和G1的各个方面扯上必装逼成功加分因为几乎他也不懂，因为G1也是采用化整为0的这种分开治理的思想）
23、nginx,正向代理，反向代理,阿里特意问了nginx原理和apache的区别以及出个问题故意让你答和lua脚本结合，然后会继续问你会不会写？nginx与tomcat的区别
24、zookeeper干什么的说说（多说为益扯上补充上如何实现分布式锁，同步流程，watcher机制代码流程选举算法绝对装逼99分），分布式锁怎么实现（额外说上尽可能避免分布式锁怎么避免为什么避免绝逼加分）。阿里直接让说了选举算法（描述大体过程和关键点即可不需要太详细了）
		ZooKeeper机制规定：同一个目录下只能有一个唯一的文件名。例如：我们在Zookeeper目录/test目录下创建，两个客户端创建一个名为Lock节点，只有一个能够成功。
		算法思路: 利用名称唯一性，加锁操作时，只需要所有客户端一起创建/test/Lock节点，只有一个创建成功，成功者获得锁。解锁时，只需删除/test/Lock节点，其余客户端再次进入竞争创建节点，
	直到所有客户端都获得锁。
25、redis两种持久化方式（过程，优缺点最好说上）
	rdb,aof
26、复合索引的使用，什么时候走什么时候不走，举例
27、如何实现session共享
28、多线程下如何实现唯一ID（多种技术，多说为益，越高大尚越好）
	1，数据库主键自增，在对表进行高并发单记录插入时需要加入事物机制，否则会出现Id重复的问题
	2，
29、js闭包
30、说说我游览器输入www.baidu.com之后怎么一个数据传输过程，主要考网络模型

		1.首先使用了应用层的 HTTP ( HyperText Transfer Protocol )协议.
应用层负责的事是你的业务逻辑,一个HTTP请求:
GET /index.html
这个请求包含了,
我想干什么?GET,不是PUT.
我想GET什么?index.html,不是index.php.
我想从哪GET?根目录下(/),不是别的(/other)下.
2.然后使用了传输层的 TCP (Transmission Control Protocol) 协议.
TCP 的主要任务是运输它的上层协议的业务逻辑内容,不过可是不很容易,它至少得解决:
后发送的比之前发送的还早到了怎么办?
对方是否掉线了?还传吗?
网络堵塞的时候付款信息是不是得比其它信息先走?
TCP 要保证,要么到不了,要么就得正确地到
3.接着使用了网络层的 IP (Internet Protocol) 协议.
目前,IP 协议包装了上层的数据并传送到指定的 ip 地址.
我们知道有个 MAC 地址,那为何还要发明个 ip 地址呢?要是只有 MAC 地址,我让百度下线就太容易了,把我自己的 MAC 地址改成百度的 MAC 地址,我们一冲突你们就都不能访问了.要想让 Internet 能够正常互相访问需要有个权威的人去维护 ip 地址,不能每个人都能生成使用,实际上确实有那么个机构负责分配 ip 地址,你只能在你的网络或者系统上作威作福,你可影响不到整个 Internet,正应了协议的名称.
4.接着使用了以太网 (Ethernet).
本层包装了上层的数据,使之可以在多种介质上传输,比如无线,光纤,电话线等,而以太网就是来使之能够在各种网线上传输的


31、7层模式都是那几个，有哪些协议，怎么传输的，丢包问题，粘包问题，楚楚街特意问的
	

32、java里有哪些集合接口，这些集合的区别是什么，说的越多越深越好，再就是LinkedList的扩容机制，hashmap的扩容机制，注意JDK6,7,8好像都有变化说上绝逼加分项因为他也不知道也没注意过只是停留在JDK6上那个机制。
33、java有几种基本类型，挑出一种多大字节，取值范围，一个汉字多大空间占（注意根据不同编码说而且不同的汉字如复杂汉字就特殊也是加分点我是根据UTF-8，还追问了GBK）
34、sql执行的过程说说（当时我只说了是9个过程，但具体记不清了，而且会有几个过程缓存住）
35、什么是笛卡尔积，一个SQL语句where后边有很多and和组后group,limit怎么执行的具体说说
36、设计模式你熟悉哪些，然后挑出几个来说说具体怎么设计（最好能画类图，有6大关系搞懂，扩展说上都是加分项，再想加分，就说对某个模式如单例有很多种最牛逼的一种是哪个牛逼的面试官有时也不知道）
37、说说mybatis的原理，如果让你设计持久层，你会怎么设计（本人从扩展、灵活、性能几方面切入的）
38、让你画架构，各种负载集群的那种，特意问如果没有f5怎么着
39、秒杀中超卖问题有多种方式实现让说说（阿里那本书和一些博客中介绍的很多）
40、各种GC算法一定要熟记整个过程一丝不挂的搞熟练，阿里让画画各个过程，很多都问为什么这么做，为什么分带收集（按我前边说的，把G1具体过程捎带扯上绝逼加分因为他们很少懂）
41、一些算法递归，二叉树都要懂，经常性的会面试的差不多了最后问你些数据结构方面熟悉吗，自己要会园上。
42、100阶乘几个零思考会快速回答上来（面试第一次完全卡住了，主要是否看真那么钻研问题，阿里的，其实想想也挺简单，只不过那种场景让你快速答出我是思维有点乱了）
43、内存资源很有限，但是相同的操作不断的分配和释放内存，内存已经被这种频繁的操作被分配很多了，怎么优化（说实话，题目我也没真正搞懂说了下缓存区他说是一方面说其他的什么多线程看样子不是那样的，阿里的）
44、很大的字符串文件，怎么统计某个字符串出现的频率（其实考你拆分思想用多线程去处理，具体怎么拆分阿里的人也只说用脚本说主要考你拆分的思想，说让JAVA API和Guava处理这种简短字符串情况的API绝对是加分的）
45、Guava用过哪些API，具体说说
46、JVM的各个带说说画画，说的越具体越好，结合上调优和GC，各个命令和参数配置绝逼加分，越细越好，细的他都不知道必加分（阿里的人具体还追问了参数怎么写辛亏我知道常见就那几个）
47、倒水问题，5升和3升如何称出4升水，其他技术都回答的差不多最后问的逻辑题
48、mysql中2个引擎的区别，几乎家家必问
49、mysql中char与varchar的区别，什么情况下用char比较好，int(5)类型字段如果存的数据超出大小会怎么样
50、悲观锁、悲观锁解释解释，还有脏读和什么读一堆挂读的概念问我怎么理解他们，醉了，还有事务ACID分别说说，什么叫原子性，什么叫一致性，事务的隔离级别哪几种
51、redis的事务,watcher,当watcher事务提交失败会返回信息吗，返回什么信息
52、连接池用过哪些，阿里特意问了druid的特点（特点好多，多说为益），为什么采用连接池
53、dubbo的整个调用过程，让画画，就是那4个，服务端启动注册消费端订阅那个，RPC的过程最好能顺口说出加分项。还有问dubbo服务端和消费端都配置了那个生效？dubbo里的jetty干啥用的？ 
54、zk除了做分布式锁和注册中心，还能用来干啥
55、重载和重写的区别，越详细越好，说的越多越好
56、接口和抽象类区别，越详细越好，及为什么需要抽象类
57、时间片解释下，上下文切换解析下，什么情况下会影响上下文切换，怎么避免过多的上下文切换
58、一个线程，从连接池里获取一个连接connection后，然后这个线程开辟了2个子线程，把这个connection传给它俩个，提交数据会有影响吗，为什么（现在想想自己解释的有点牵强，应该从事务的传播行为和级别入手，也可能其他，肯定面试官自己使用不当遇到的bug问题,如有合理解释的或者特意能做了实验的，一定要告诉大家一声）
59、什么叫复制构造函数，构造函数的重载
60、JVM的内存分配？（要熟记，越细越好）
61、TCP的三次握手四次拜拜要熟记
62、浮点类型为什么有时候不精确，详细说出来，怎么解决
63、int类型在32位和64位有什么不同
		
64、zk分布式锁具体怎么实现（58，美团的都问了，最好亲自用代码编写下，思路搞懂）

65、给一个字符串类型的数字，不调用java直接转的API写一个方法转换出来（58的不知道那个技术老大想考啥思路就是转字符数组利用ASSII编码，问他弄这个干啥他也不说）
66、给我几张表，写几个个SQL（我之前利用子查询，后来他说不利用子查询一条sql查出来，其实就是连接查询group，和count然后再利用统计的数过滤下，其中count(*)和count(1)和面试官争辩了起来，他也不确定后来就过了，美团的）
67、写个单例模式（其他有很多种，我也知道他想考啥，但是想加分，写最好的2点兼顾的利用私有静态内部类，网上提到的很少，优化书中的，面试官认为我是错的让我确定下，后来给他讲通了）
68、熟悉哪些设计模式（然后让你简单说说，58让写的代理，把各个类图之间的关系说清楚及接口的设计加分的）
69、代理有几种？静态代理和动态代理有什么区别？什么情况下用什么具体说说？
70、让我说下OOP里的单一原则的定义（他说这个定义非常重要，非要我说出定义），我拿出具体的设计实例说明哪些地方设计体现单一原则（他还是让说定义，美团的，醉了，定义我肯定没仔细推敲过，大家可以推敲下）

71、JVM的内存分配，内存溢出，内出调优，GC调优，GC算法，G1收集器，还有参数常用参数名（美团的那个人一直让我说哪个具体参数名字，我说JVM虚拟机参数列表一查就知道了知道那是工具就行，我看他的样子可能也没记住，还是拿着笔记本查呢，醉了，最好几个常用的记住看样子也是有意而无害的我都记个大概的样子），如何调优如何具体优化举例子越细越好什么阀值具体到什么GC算法在什么情况下怎么设置他的什么样的参数越细越好，还有问题诊断，具体怎么定位，最好前提你说上基于java的哪个版本规范，哪个虚拟机，因为不同版本不同虚拟机肯定有所不同，能说出来必加分(呵呵，装的你多严谨，如装逼成功肯定加分)

72、NIO与IO的区别，什么情况下用谁，具体说说例子

73、dubbo支持几种协议，协议的区别，容错机制，什么情况用什么，RPC的过程，dubbo是如何实现负载均衡的（源码级别），负载均衡策略，改过监控的中心吗，如何优化调用，怎么部署，zk挂掉3个挂掉2个会怎么样，为什么，看过dubbo源码吗
74、哈希一致算法具体描述下（最后自己用java实现下或理解了），为什么要用hash一致算法
75、在CPU不考虑的情况下内存有限的情况下计算最大并发数大概多少（linux下有很多注意事项会约束给他说说他可能也想不到都是加分的，然后再让你不考虑这些因素怎么计算说说，也和系统位数有关，也有对应的计算公式）
76、在内存不考虑，8核CPU，挂起时间（好像是单个线程执行任务时间）30ms，CPU满负载最大多少并发（其实他当时也没说清楚，后来追问下补充了响应时间1S）
77、给你写出2个数组，在纸上写个方法查出相同的元素（想考细节，把大体写出来之后给他说明一些特殊情况的处理），继续追问如何优化这个方法（说说自己的见解，如相同元素很多的情况用什么瞎吹呗），最好把JDK,commons，guava的相关API说下再说名你的理由啥的都是加分的
78、linux命令用过哪些，说的越高大尚越好(如查看上下文切换命令)，常用的肯定要说上
79、乐观锁问题，一般不直接问，给你说个分布式场景（用时间戳版本号啥的解决）
80、CAS知道吗，说说（多多益善，说上ABA问题必加分有时面试官也不知道，扯上volite和锁区别什么场景下用谁必加分）
81、让画ER图，时序图
82、一个类里几个静态方法和几个普通方法，几个静态方法里有几个加synchronized，普通方法里有几个也加synchronized，这4种方法组合情况各个情况下同一个实例在多个线程里用到时阻塞不阻塞问题
83、tomcat里有几个端口的配置？同一个tomcat能同时配置2个端口吗？
84、tomcat里如何禁止服务端自动创建session
85、servlet和过滤器，监听器，servlet启动顺序是什么样的
86、spring的核心配置文件名是什么，具体描述一下里边的重要的配置,spring和mybatis集成的后的配置文件又怎么配置，需要配置什么,spring和springMVC的区别
87、mybatis的配置文件怎么组织的，如何配置
88、spring的AOP和IOC具体描述下，干什么的，怎么实现解偶的，它们是底层通过什么实现的

89、类加载有哪些，机制是什么，类初始化的时机（那4个）有哪些 加载，验证，连接。。。。。。。。。。。。。。。。。，初始化

90、一个对象为null一定会被GC掉吗（肯定不会，至少有2个过程，给他描述下，越细越好，他可能也不知道，楚楚街问的）

91、final static 和static初始化都是什么时候初始化的？

92、静态代码块和普通代码块有什么区别，什么场景下使用
		静态代码块只执行一遍，在前面。普通代码块根据实例执行多遍。
93、shell脚本写过吗？（就一家问到了就简答追问了下开头的声明干啥的）
	
94、看过哪些书籍，平常怎么学习这些知识的
	
95、conncurrentHashMap和hashmap的区别（6,7,8可能都所不同，能说出来必加分他可能也没注意过，不说也没关系）
96、mongoDB,redis分片，主从，有问到，问到了都是简单问问，一般都是自己补充上其他东西，最好都要清楚，加分的，也以防万一,redis持久化2种方式有哪些问到有，然后你追加一些注意事项
97、平常你遇到的一些不规范性问题，能再优化的问题，具体说说例子
98、nginx具体怎么配置切换服务器和负载均衡策略，说说具体的配置地方
99、那些并发工具就不说了，最好都知道干啥用的，问到也有但是很少不知道到问啥
100、netty和mina到时有提到的，但是就是简单问问知道吗，用过吗这些问题，当然自己对它们越熟练越清除越好
101、tomcat具体在哪配置连接池，能配置哪些信息
102、java反射类的私有方法与普通方法相比，需要多处理什么？












103、java中有哪些集合？这些集合有什么区别，arrayList和HashMap的扩容机制（集合说的越多越好，各个集合都有什么区别，什么场景下用什么，注意些什么，有些6，7，8有不同，能说出来更好）
104、zk有哪几种类型的节点，又有哪些监听事件，具体说说？
105、用过哪几种抓包工具？报文结构？
106、如何中断一个线程？线程在那种状态才可以中断？
2. 介绍Java中垃圾回收机制，程序员平时需要关注这个吗？为什么？请举例说明。
3. 数据库隔离级别介绍、举例说明。
4. override和overload的区别。
5. 求二叉树的最大距离（即相距最远的两个叶子节点），写代码。
6. 两个栈实现一个队列，写代码。
7. 你觉得你的优势是什么？有什么技术薄弱点吗？
8. 目前手上有offer吗？
二面（40 minutes）：
1. 详细介绍研究生期间的小论文项目。
2. 求二叉树的宽度，先简介思路再写代码。
3. Hashmap、Hashtable和cocurrentHashMap的区别，要讲出它们各自的实现原理才行，比如Hashmap的扩容机制、cocurrentHashMap的桶分割原理、多线程安全性。
4. 进程调度算法，有哪些算法比较难实现？
5. linux下如何修改进程优先级？（nice命令的使用）。
6. linux下性能监控命令uptime介绍，平均负载的具体含义是什么？建议看server load概念。
7. linux下如何调试程序？说到gdb，具体如何调试？如何查看core文件中的堆栈信息等（bt指令）。
三面（1 hour and twenty minutes）：
1. 介绍我研究生期间的论文，讲的很详细，每个点具体采用的技术、实现方法等，花了较长时间。
2. 打印二叉树两个叶子节点间的路径，写代码（汗，百度这么喜欢问二叉树）。
3. 字符串中第一个只出现一次的字符，如何优化算法使得遍历次数更少？
4. socket编程相关，如果服务器这边调用write写了100个字节的数据，客户端想要获得这个数据，是直接用read系统调用，参数也是100吗？
5. 百度新闻缓存预算问题：一般为了追求时间性能，都需要缓存一些新闻数据，你怎么计算所需预算？然后申请需要的主机……
6. 多线程的适用场景是什么？为啥要用多线程？

最后面试官说像计算机体系结构、操作系统这样的书一定要看国外的，国内的有时候会误导人。


1、介绍一下项目。

2、提了一个问题：上千万条记录，统计出重复记录最多的前N条。

3、一个概率题：54张扑克牌，除去两张大小王剩下52张扑克牌。问红桃A和黑桃A同时被一个人拿到的概率是多少?

4、多个线程访问共享内存时因该怎么办?

5、在写程序遇到问题的时候，通常采用什么调试方法?

6、一个client/server的协议问题

7、剩下就是随便聊聊，比如有缺点、期望工作的性质、职业规划等

1.谈谈你对数据库中索引的理解

2.现在普通关系数据库用得数据结构是什么类型的数据结构

3.索引的优点和缺点

4.session和cache的区别是什么

5.如果有几千个session，怎么提高效率

6.session是存储在什么地方，以什么形式存储的。
TCP和UDP的区别；
TCP如何保证可靠传输；
HTTP的报文格式；
HTTP（请求和回复）的头部包含哪些内容；
cookie是在头部还是数据段，为什么；
HTTP回复的状态码你知道哪些；

然后是Java面向对象：
说说多态的理解：我说了重载和重写，但他说要说多态是什么，我一直以为多态就是指重载和重写...
Java的设计模式：问我什么事装饰模式（还是门面模式记不起了），我说只知道工厂模式和单例模式；
问单例模式的实现；
也问了Java多线程的实现及同步；

操作系统：
问进程和线程的区别；
问操作系统如何实现多进程的调度；

软件工程：
问开发的瀑布模型；
问开发软件项目的历程；
问系统设计和详细设计的区别；类图是在哪个阶段画的；
我自己平常开发如何做测试；
如何做到覆盖测试，覆盖到每个分支；

（1）自我介绍。
（2）JVM如何加载一个类的过程，双亲委派模型中有哪些方法？
（3）HashMap如何实现的？
（4）HashMap和ConcurrentHashMap区别，ConcurrentHashMap线程安全吗，ConcurrentHashMap如何保证线程安全？
（5）HashMap和HashTable区别，HashTable线程安全吗？
（6）进程间通信有哪几种方式？
（7）JVM分为哪些区，每一个区干吗的？
（8）JVM如何GC，新生代，老年代，持久代，都存储哪些东西？
（9）GC用的引用可达性分析算法中，哪些对象可作为GC Roots对象？
（10）快速排序，过程，复杂度？
（11）什么是二叉平衡树，如何插入节点，删除节点，说出关键步骤。
（12）TCP如何保证可靠传输？三次握手过程？
（13）TCP和UDP区别？
（14）滑动窗口算法？
（15）Linux下如何进行进程调度的？
（16）Linux下你常用的命令有哪些？
（17）操作系统什么情况下会死锁？
（18）常用的hash算法有哪些？
（19）什么是一致性哈希？
（20）如何理解分布式锁？
（21）数据库中的范式有哪些？
（22）数据库中的索引的结构？什么情况下适合建索引？
（23）Java中的NIO，BIO，AIO分别是什么？
（24）用什么工具调试程序？JConsole，用过吗？
（25）现在JVM中有一个线程挂起了，如何用工具查出原因？
（26）线程同步与阻塞的关系？同步一定阻塞吗？阻塞一定同步吗？
（27）同步和异步有什么区别？
（28）线程池用过吗？
（29）如何创建单例模式？说了双重检查，他说不是线程安全的。如何高效的创建一个线程安全的单例？
（30）concurrent包下面，都用过什么？
（31）常用的数据库有哪些？redis用过吗？
（32）了解hadoop吗？说说hadoop的组件有哪些？hdfs，hive,hbase,zookeeper。说下mapreduce编程模型。
（33）你知道的开源协议有哪些？
（34）你知道的开源软件有哪些？
（35）你最近在看的书有哪些？
（36）你有什么问题要问我吗？

基本上就这样了，还有一些零星的问题想不起来了，从7点到8点多，持续了一个多小时。我想说，我的手好累啊。。下次一定要戴个耳机。

又想起来几个。

（37）了解哪些设计模式？说说都用过哪些设计模式
（38）如何判断一个单链表是否有环？
（39）操作系统如何进行分页调度？
（40）匿名内部类是什么？如何访问在其外面定义的变量？

基层的东西多点，JVM优化算法，线程池优化
还有GC的各种算法

还有GC的各种算法
面试经历：
一面：
1、详述在项目中遇到的难点以及如何解决的
2、项目大体框架，以及自己所做部分的框架，并拿出其中一个流程具体描述在该框架中的工作流程
3、java多线程是否有了解，描述java中Thread和Runnable的区别，项目中主要用哪个类，为什么？重点函数是什么？
4、String类与StringBuffer类有何区别及联系？
5、描述java内存模型？
6、描述java垃圾回收机制？
7、spring主要用它来做什么？具体的机制是什么？比如是如何做到IOC的？
8、maven的用途及好处，如何创建一个maven仓库？
9、sql语句写查询
10、写一个设计模式，单例模式，写了内部类的实现方式，追问为何这种方式可以实现延迟加载以及避免多线程引起的线程不安全。
11、 简单的逻辑题：六米长的桌子上，每隔一米放一个小球，共5个小球（两个端点不放），5个小球完全一样，小球可向左或向右移动，相遇后将以相同速度向左右继 续运动，求问5个小球运动轨迹最长是多少？答案很简单，但是思路很重要，需要答出小球不管是否经历过碰撞，其最远轨迹都是一样的这一点，可以从两个小球的 情况出发考虑。
12、写一个排序算法。
二面：
1、简述自己做过的项目，项目背景，自己所做部分的模型图
2、spring ioc机制原理
3、java回收机制，是否有函数可以进行垃圾回收？
4、写一个除单例模式之外的设计模式，写了构造者模式
5、是否有遇到过高并发的问题，如何解决
6、写算法：求出1~n中包含1的个数，比如{1,10,11,12}中共包含5个1。
7、写算法：一个数组循环右移K位。进阶：如果只能使用一个额外的存储空间。
三面：
2、对工作压力强度是否有足够的心理准备？
3、足球积分赛，10支足球队进行单循环制比赛，胜一场得3分，平一场得1分，负一场得0分，问如何判断一个数字是否有可能出现在积分榜中。
4、给若干张5元纸币，若干张2元纸币，问是否能使用不找零的方式从商场中买得一件商品，写出源码

Hashtable和Hashmap的应用场景
Hashtable和Hashmap的区别
Array和ArrayList区别
Thread和Runnable区别
cache和buffer
Java 线程面试问题

在任何Java面试当中多线程和并发方面的问题都是必不可少的一部分。如果你想获得任何股票投资银行的前台资讯职位，那么你应该准备很多关于多线程的问题。在投资银行业务中多线程和并发是一个非常受欢迎的话题，特别是电子交易发展方面相关的。他们会问面试者很多令人混淆的Java线程问题。面试官只是想确信面试者有足够的Java线程与并发方面的知识，因为候选人中有很多只浮于表面。用于直接面向市场交易的高容量和低延时的电子交易系统在本质上是并发的。下面这些是我在不同时间不同地点喜欢问的Java线程问题。我没有提供答案，但只要可能我会给你线索，有些时候这些线索足够回答问题。现在引用Java5并发包关于并发工具和并发集合的问题正在增多。那些问题中ThreadLocal、Blocking Queue、Counting Semaphore和ConcurrentHashMap比较流行。


15个Java多线程面试题及回答

1)现在有T1、T2、T3三个线程，你怎样保证T2在T1执行完后执行，T3在T2执行完后执行？

这个线程问题通常会在第一轮或电话面试阶段被问到，目的是检测你对”join”方法是否熟悉。这个多线程问题比较简单，可以用join方法实现。

2)在Java中Lock接口比synchronized块的优势是什么？你需要实现一个高效的缓存，它允许多个用户读，但只允许一个用户写，以此来保持它的完整性，你会怎样去实现它？

lock接口在多线程和并发编程中最大的优势是它们为读和写分别提供了锁，它能满足你写像ConcurrentHashMap这样的高性能数据结构和有条件的阻塞。Java线程面试的问题越来越会根据面试者的回答来提问。我强烈建议在你去参加多线程的面试之前认真读一下Locks，因为当前其大量用于构建电子交易终统的客户端缓存和交易连接空间。

3)在java中wait和sleep方法的不同？

通常会在电话面试中经常被问到的Java线程面试问题。最大的不同是在等待时wait会释放锁，而sleep一直持有锁。Wait通常被用于线程间交互，sleep通常被用于暂停执行。

4）用Java实现阻塞队列。

这是一个相对艰难的多线程面试问题，它能达到很多的目的。第一，它可以检测侯选者是否能实际的用Java线程写程序；第二，可以检测侯选者对并发场景的理解，并且你可以根据这个问很多问题。如果他用wait()和notify()方法来实现阻塞队列，你可以要求他用最新的Java 5中的并发类来再写一次。

5）用Java写代码来解决生产者——消费者问题。

与上面的问题很类似，但这个问题更经典，有些时候面试都会问下面的问题。在Java中怎么解决生产者——消费者问题，当然有很多解决方法，我已经分享了一种用阻塞队列实现的方法。有些时候他们甚至会问怎么实现哲学家进餐问题。

6）用Java编程一个会导致死锁的程序，你将怎么解决？

这是我最喜欢的Java线程面试问题，因为即使死锁问题在写多线程并发程序时非常普遍，但是很多侯选者并不能写deadlock free code（无死锁代码？），他们很挣扎。只要告诉他们，你有N个资源和N个线程，并且你需要所有的资源来完成一个操作。为了简单这里的n可以替换为2，越大的数据会使问题看起来更复杂。通过避免Java中的死锁来得到关于死锁的更多信息。

7) 什么是原子操作，Java中的原子操作是什么？

非常简单的java线程面试问题，接下来的问题是你需要同步一个原子操作。

8) Java中的volatile关键是什么作用？怎样使用它？在Java中它跟synchronized方法有什么不同？

自从Java 5和Java内存模型改变以后，基于volatile关键字的线程问题越来越流行。应该准备好回答关于volatile变量怎样在并发环境中确保可见性。

9) 什么是竞争条件？你怎样发现和解决竞争？

这是一道出现在多线程面试的高级阶段的问题。大多数的面试官会问最近你遇到的竞争条件，以及你是怎么解决的。有些时间他们会写简单的代码，然后让你检测出代码的竞争条件。可以参考我之前发布的关于Java竞争条件的文章。在我看来这是最好的java线程面试问题之一，它可以确切的检测候选者解决竞争条件的经验，or writing code which is free of data race or any other race condition。关于这方面最好的书是《Concurrency practices in Java》。

10) 你将如何使用thread dump？你将如何分析Thread dump？

在UNIX中你可以使用kill -3，然后thread dump将会打印日志，在windows中你可以使用”CTRL+Break”。非常简单和专业的线程面试问题，但是如果他问你怎样分析它，就会很棘手。

11) 为什么我们调用start()方法时会执行run()方法，为什么我们不能直接调用run()方法？

这是另一个非常经典的java多线程面试问题。这也是我刚开始写线程程序时候的困惑。现在这个问题通常在电话面试或者是在初中级Java面试的第一轮被问到。这个问题的回答应该是这样的，当你调用start()方法时你将创建新的线程，并且执行在run()方法里的代码。但是如果你直接调用run()方法，它不会创建新的线程也不会执行调用线程的代码。阅读我之前写的《start与run方法的区别》这篇文章来获得更多信息。

12) Java中你怎样唤醒一个阻塞的线程？

这是个关于线程和阻塞的棘手的问题，它有很多解决方法。如果线程遇到了IO阻塞，我并且不认为有一种方法可以中止线程。如果线程因为调用wait()、sleep()、或者join()方法而导致的阻塞，你可以中断线程，并且通过抛出InterruptedException来唤醒它。我之前写的《How to deal with blocking methods in java》有很多关于处理线程阻塞的信息。

13)在Java中CycliBarriar和CountdownLatch有什么区别？

这个线程问题主要用来检测你是否熟悉JDK5中的并发包。这两个的区别是CyclicBarrier可以重复使用已经通过的障碍，而CountdownLatch不能重复使用。

14) 什么是不可变对象，它对写并发应用有什么帮助？

另一个多线程经典面试问题，并不直接跟线程有关，但间接帮助很多。这个java面试问题可以变的非常棘手，如果他要求你写一个不可变对象，或者问你为什么String是不可变的。

15) 你在多线程环境中遇到的常见的问题是什么？你是怎么解决它的？

多线程和并发程序中常遇到的有Memory-interface、竞争条件、死锁、活锁和饥饿。问题是没有止境的，如果你弄错了，将很难发现和调试。这是大多数基于面试的，而不是基于实际应用的Java线程问题。

补充的其它几个问题：

1) 在java中绿色线程和本地线程区别？
绿色线程执行用户级别的线程，且一次只使用一个OS线程。本地线程用的是OS线程系统，在每个JAVA线程中使用一个OS线程。在执行java时，可通过使用-green或 -native标志来选择所用线程是绿色还是本地
2) 线程与进程的区别？
线程是指进程内的一个执行单元,也是进程内的可调度实体.

与进程的区别:

地址空间:进程内的一个执行单元;进程至少有一个线程;它们共享进程的地址空间;而进程有自己独立的地址空间;

资源拥有:进程是资源分配和拥有的单位,同一个进程内的线程共享进程的资源

线程是处理器调度的基本单位,但进程不是.

二者均可并发执行.

进程和线程都是由操作系统所体会的程序运行的基本单元，系统利用该基本单元实现系统对应用的并发性。进程和线程的区别在于：

简而言之,一个程序至少有一个进程,一个进程至少有一个线程。线程的划分尺度小于进程，使得多线程程序的并发性高。

另外，进程在执行过程中拥有独立的内存单元，而多个线程共享内存，从而极大地提高了程序的运行效率。线程在执行过程中与进程还是有区别的。每个独立的线程有一个程序运行的入口、顺序执行序列和程序的出口。但是线程不能够独立执行，必须依存在应用程序中，由应用程序提供多个线程执行控制。

从逻辑角度来看，多线程的意义在于一个应用程序中，有多个执行部分可以同时执行。但操作系统并没有将多个线程看做多个独立的应用，来实现进程的调度和管理以及资源分配。这就是进程和线程的重要区别。

进程是具有一定独立功能的程序关于某个数据集合上的一次运行活动,进程是系统进行资源分配和调度的一个独立单位.

线程是进程的一个实体,是CPU调度和分派的基本单位,它是比进程更小的能独立运行的基本单位.线程自己基本上不拥有系统资源,只拥有一点在运行中必不可少的资源(如程序计数器,一组寄存器和栈),但是它可与同属一个进程的其他的线程共享进程所拥有的全部资源.

一个线程可以创建和撤销另一个线程;同一个进程中的多个线程之间可以并发执行.

3) 什么是多线程中的上下文切换？
	操作系统管理很多进程的执行。有些进程是来自各种程序、系统和应用程序的单独进程，而某些进程来自被分解为很多进程的应用或程序。当一个进程从内核中移出， 另一个进程成为活动的，这些进程之间便发生了上下文切换。操作系统必须记录重启进程和启动新进程使之活动所需要的所有信息。这些信息被称作上下文，它描述 了进程的现有状态。当进程成为活动的，它可以继续从被抢占的位置开始执行。

当线程被抢占时，就会发生线程之间的上下文切换。如果线程属于相同的进程，它们共享相同的地址空间，因为线程包含在它们所属于的进程的地址空间内。这样，进程需要恢复的多数信息对于线程而言是不需要的。尽管进程和它的线程共享了很多内容，但最为重要的是其地址空间和资源，有些信息对于线程而言是本地且唯一 的，而线程的其他方面包含在进程的各个段的内部。
4)死锁与活锁的区别，死锁与饥饿的区别？
		死锁： 是指两个或两个以上的进程在执行过程中，因争夺资源而造成的一种互相等待的现象，若无外力作用，它们都将无法推进下去。此时称系统处于死锁状态或系统产生 了死锁，这些永远在互相等待的进程称为死锁进程。 由于资源占用是互斥的，当某个进程提出申请资源后，使得有关进程在无外力协助下，永远分配不到必需的资源而无法继续运行，这就产生了一种特殊现象：死锁。

虽然进程在运行过程中，可能发生死锁，但死锁的发生也必须具备一定的条件，死锁的发生必须具备以下四个必要条件。

互斥条件：指进程对所分配到的资源进行排它性使用，即在一段时间内某资源只由一个进程占用。如果此时还有其它进程请求资源，则请求者只能等待，直至占有资源的进程用毕释放。
请求和保持条件：指进程已经保持至少一个资源，但又提出了新的资源请求，而该资源已被其它进程占有，此时请求进程阻塞，但又对自己已获得的其它资源保持不放。

不剥夺条件：指进程已获得的资源，在未使用完之前，不能被剥夺，只能在使用完时由自己释放。

环路等待条件：指在发生死锁时，必然存在一个进程——资源的环形链，即进程集合{P0，P1，P2，···，Pn}中的P0正在等待一个P1占用的资源；P1正在等待P2占用的资源，……，Pn正在等待已被P0占用的资源。

活锁：指事物1可以使用资源，但它让其他事物先使用资源；事物2可以使用资源，但它也让其他事物先使用资源，于是两者一直谦让，都无法使用资源。

活锁有一定几率解开。而死锁（deadlock）是无法解开的。

避免活锁的简单方法是采用先来先服务的策略。当多个事务请求封锁同一数据对象时，封锁子系统按请求封锁的先后次序对事务排队，数据对象上的锁一旦释放就批准申请队列中第一个事务获得锁。
5) Java中用到的线程调度算法是什么？
	计算机通常只有一个CPU,在任意时刻只能执行一条机器指令,每个线程只有获得CPU的使用权才能执行指令. 所谓多线程的并发运行,其实是指从宏观上看,各个线程轮流获得CPU的使用权,分别执行各自的任务.在运行池中,会有多个处于就绪状态的线程在等待CPU,java虚拟机的一项任务就是负责线程的调度,线程调度是指按照特定机制为多个线程分配CPU的使用权

java虚拟机采用抢占式调度模型，是指优先让可运行池中优先级高的线程占用CPU，如果可运行池中的线程优先级相同，那么就随机选择一个线程，使其占用CPU。处于运行状态的线程会一直运行，直至它不得不放弃CPU。

一个线程会因为以下原因而放弃CPU。

java虚拟机让当前线程暂时放弃CPU，转到就绪状态，使其它线程获得运行机会。

当前线程因为某些原因而进入阻塞状态

线程结束运行

需要注意的是，线程的调度不是跨平台的，它不仅仅取决于java虚拟机，还依赖于操作系统。在某些操作系统中，只要运行中的线程没有遇到阻塞，就不会放弃CPU；

在某些操作系统中，即使线程没有遇到阻塞，也会运行一段时间后放弃CPU，给其它线程运行的机会。 java的线程调度是不分时的，同时启动多个线程后，不能保证各个线程轮流获得均等的CPU时间片。 如果希望明确地让一个线程给另外一个线程运行的机会，可以采取以下办法之一。

调整各个线程的优先级

让处于运行状态的线程调用Thread.sleep()方法

让处于运行状态的线程调用Thread.yield()方法

让处于运行状态的线程调用另一个线程的join()方法
6) 在Java中什么是线程调度？
	
7) 在线程中你怎么处理不可捕捉异常？
捕捉异常有两种方法。

把线程的错误捕捉到，往上抛

通过线程池工厂，把异常捕捉到，uncaughtException往log4j写错误日志

示例代码：

publicclassTestThreadimplementsRunnable{publicvoid run(){thrownewRuntimeException("throwing runtimeException.....");}}
当线程代码抛出运行级别异常之后，线程会中断。主线程不受这个影响，不会处理这个，而且根本不能捕捉到这个异常，仍然继续执行自己的代码。

方法1）代码示例：publicclassTestMain{publicstaticvoid main(String[] args){try{TestThread t =newTestThread();ExecutorServiceexec=Executors.newCachedThreadPool();Future future =exec.submit(t);exec.shutdown();
               future.get();//主要是这句话起了作用，调用get()方法，异常重抛出，包装在ExecutorException}catch(Exception e){//这里可以把线程的异常继续抛出去System.out.println("Exception Throw:"+ e.getMessage());}}}
方法2）代码示例：

publicclassHandlerThreadFactoryimplementsThreadFactory{publicThread newThread(Runnable runnable){Thread t =newThread(runnable);MyUncaughtExceptionHandler myUncaughtExceptionHandler =newMyUncaughtExceptionHandler();
          t.setUncaughtExceptionHandler(myUncaughtExceptionHandler);return t;}}publicclassMyUncaughtExceptionHandlerimplementsThread.UncaughtExceptionHandler{publicvoid uncaughtException(Thread t,Throwable e){System.out.println("write logger here:"+ e);}}publicclassTestMain{publicstaticvoid main(String[] args){try{TestThread t =newTestThread();ExecutorServiceexec=Executors.newCachedThreadPool(newHandlerThreadFactory());exec.execute(t);}catch(Exception e){System.out.println("Exception Throw:"+ e.getMessage());}}}
8) 什么是线程组，为什么在Java中不推荐使用？
	ThreadGroup线程组表示一个线程的集合。此外，线程组也可以包含其他线程组。线程组构成一棵树，在树中，除了初始线程组外，每个线程组都有一个父线程组。

允许线程访问有关自己的线程组的信息，但是不允许它访问有关其线程组的父线程组或其他任何线程组的信息。线程组的目的就是对线程进行管理。节省频繁创建和销毁线程的开销，提升线程使用效率。

衍生问题：线程组和线程池的区别在哪里？

一个线程的周期分为：创建、运行、销毁三个阶段。处理一个任务时，首先创建一个任务线程，然后执行任务，完了，销毁线程。而线程处于运行状态的时候，才是真的在处理我们交给它的任务，这个阶段才是有效运行时间。所以，我们希望花在创建和销毁线程的资源越少越好。如果不销毁线程，而这个线程又不能被其他的任务调用，那么就会出现资源的浪费。为了提高效率，减少创建和销毁线程带来时间和空间上的浪费，出现了线程池技术。这种技术是在开始就创建一定量的线程，批量处理一类任务，等待任务的到来。任务执行完毕后，线程又可以执行其他的任务。等不再需要线程的时候，就销毁。这样就省去了频繁创建和销毁线程的麻烦。
9) 为什么使用Executor框架比使用应用创建和管理线程好？
	大多数并发应用程序是以执行任务（task）为基本单位进行管理的。通常情况下，我们会为每个任务单独创建一个线程来执行。

这样会带来两个问题：

一，大量的线程（>100）会消耗系统资源，使线程调度的开销变大，引起性能下降；

二，对于生命周期短暂的任务，频繁地创建和消亡线程并不是明智的选择。因为创建和消亡线程的开销可能会大于使用多线程带来的性能好处。

一种更加合理的使用多线程的方法是使用线程池（Thread Pool）。 java.util.concurrent 提供了一个灵活的线程池实现：Executor 框架。这个框架可以用于异步任务执行，而且支持很多不同类型的任务执行策略。它还为任务提交和任务执行之间的解耦提供了标准的方法，为使用 Runnable 描述任务提供了通用的方式。 Executor的实现还提供了对生命周期的支持和hook 函数，可以添加如统计收集、应用程序管理机制和监视器等扩展。

在线程池中执行任务线程，可以重用已存在的线程，免除创建新的线程。这样可以在处理多个任务时减少线程创建、消亡的开销。同时，在任务到达时，工作线程通常已经存在，用于创建线程的等待时间不会延迟任务的执行，因此提高了响应性。通过适当的调整线程池的大小，在得到足够多的线程以保持处理器忙碌的同时，还可以防止过多的线程相互竞争资源，导致应用程序在线程管理上耗费过多的资源。
10) 在Java中Executor和Executors的区别？
		Executor是接口，是用来执行 Runnable 任务的；它只定义一个方法- execute(Runnable command)；执行 Ruannable 类型的任务。

Executors是类，提供了一系列工厂方法用于创建线程池，返回的线程池都实现了ExecutorService接口。

Executors几个重要方法：

callable(Runnable task)： 将 Runnable 的任务转化成 Callable 的任务

newSingleThreadExecutor()： 产生一个ExecutorService对象，这个对象只有一个线程可用来执行任务，若任务多于一个，任务将按先后顺序执行。

newCachedThreadPool()： 产生一个ExecutorService对象，这个对象带有一个线程池，线程池的大小会根据需要调整，线程执行完任务后返回线程池，供执行下一次任务使用。

newFixedThreadPool(int poolSize)： 产生一个ExecutorService对象，这个对象带有一个大小为 poolSize 的线程池，若任务数量大于 poolSize ，任务会被放在一个 queue 里顺序执行。

newSingleThreadScheduledExecutor()： 产生一个ScheduledExecutorService对象，这个对象的线程池大小为 1 ，若任务多于一个，任务将按先后顺序执行。

newScheduledThreadPool(int poolSize)： 产生一个ScheduledExecutorService对象，这个对象的线程池大小为 poolSize ，若任务数量大于 poolSize ，任务会在一个 queue 里等待执行。
11) 如何在Windows和Linux上查找哪个线程使用的CPU时间最长？
	其实就是找CPU占有率最高的那个线程 Windows
	
Java多线程面试问题
1. 进程和线程之间有什么不同？
一个进程是一个独立(self contained)的运行环境，它可以被看作一个程序或者一个应用。而线程是在进程中执行的一个任务。Java运行环境是一个包含了不同的类和程序的单一进程。线程可以被称为轻量级进程。线程需要较少的资源来创建和驻留在进程中，并且可以共享进程中的资源。

2. 多线程编程的好处是什么？
在多线程程序中，多个线程被并发的执行以提高程序的效率，CPU不会因为某个线程需要等待资源而进入空闲状态。多个线程共享堆内存(heap memory)，因此创建多个线程去执行一些任务会比创建多个进程更好。举个例子，Servlets比CGI更好，是因为Servlets支持多线程而CGI不支持。

3. 用户线程和守护线程有什么区别？
当我们在Java程序中创建一个线程，它就被称为用户线程。一个守护线程是在后台执行并且不会阻止JVM终止的线程。当没有用户线程在运行的时候，JVM关闭程序并且退出。一个守护线程创建的子线程依然是守护线程。

4. 我们如何创建一个线程？
有两种创建线程的方法：一是实现Runnable接口，然后将它传递给Thread的构造函数，创建一个Thread对象；二是直接继承Thread类。若想了解更多可以阅读这篇关于如何在Java中创建线程的文章。

5. 有哪些不同的线程生命周期？
当我们在Java程序中新建一个线程时，它的状态是New。当我们调用线程的start()方法时，状态被改变为Runnable。线程调度器会为Runnable线程池中的线程分配CPU时间并且讲它们的状态改变为Running。其他的线程状态还有Waiting，Blocked 和Dead。读这篇文章可以了解更多关于线程生命周期的知识。

6. 可以直接调用Thread类的run()方法么？
当然可以，但是如果我们调用了Thread的run()方法，它的行为就会和普通的方法一样，为了在新的线程中执行我们的代码，必须使用Thread.start()方法。

7. 如何让正在运行的线程暂停一段时间？
我们可以使用Thread类的Sleep()方法让线程暂停一段时间。需要注意的是，这并不会让线程终止，一旦从休眠中唤醒线程，线程的状态将会被改变为Runnable，并且根据线程调度，它将得到执行。

8. 你对线程优先级的理解是什么？
每一个线程都是有优先级的，一般来说，高优先级的线程在运行时会具有优先权，但这依赖于线程调度的实现，这个实现是和操作系统相关的(OS dependent)。我们可以定义线程的优先级，但是这并不能保证高优先级的线程会在低优先级的线程前执行。线程优先级是一个int变量(从1-10)，1代表最低优先级，10代表最高优先级。

9. 什么是线程调度器(Thread Scheduler)和时间分片(Time Slicing)？
线程调度器是一个操作系统服务，它负责为Runnable状态的线程分配CPU时间。一旦我们创建一个线程并启动它，它的执行便依赖于线程调度器的实现。时间分片是指将可用的CPU时间分配给可用的Runnable线程的过程。分配CPU时间可以基于线程优先级或者线程等待的时间。线程调度并不受到Java虚拟机控制，所以由应用程序来控制它是更好的选择（也就是说不要让你的程序依赖于线程的优先级）。

10. 在多线程中，什么是上下文切换(context-switching)？
上下文切换是存储和恢复CPU状态的过程，它使得线程执行能够从中断点恢复执行。上下文切换是多任务操作系统和多线程环境的基本特征。

11. 你如何确保main()方法所在的线程是Java程序最后结束的线程？
我们可以使用Thread类的joint()方法来确保所有程序创建的线程在main()方法退出前结束。这里有一篇文章关于Thread类的joint()方法。

12.线程之间是如何通信的？
当线程间是可以共享资源时，线程间通信是协调它们的重要的手段。Object类中wait()\notify()\notifyAll()方法可以用于线程间通信关于资源的锁的状态。点击这里有更多关于线程wait, notify和notifyAll.

13.为什么线程通信的方法wait(), notify()和notifyAll()被定义在Object类里？
Java的每个对象中都有一个锁(monitor，也可以成为监视器) 并且wait()，notify()等方法用于等待对象的锁或者通知其他线程对象的监视器可用。在Java的线程中并没有可供任何对象使用的锁和同步器。这就是为什么这些方法是Object类的一部分，这样Java的每一个类都有用于线程间通信的基本方法

14. 为什么wait(), notify()和notifyAll()必须在同步方法或者同步块中被调用？
当一个线程需要调用对象的wait()方法的时候，这个线程必须拥有该对象的锁，接着它就会释放这个对象锁并进入等待状态直到其他线程调用这个对象上的notify()方法。同样的，当一个线程需要调用对象的notify()方法时，它会释放这个对象的锁，以便其他在等待的线程就可以得到这个对象锁。由于所有的这些方法都需要线程持有对象的锁，这样就只能通过同步来实现，所以他们只能在同步方法或者同步块中被调用。

15. 为什么Thread类的sleep()和yield()方法是静态的？
Thread类的sleep()和yield()方法将在当前正在执行的线程上运行。所以在其他处于等待状态的线程上调用这些方法是没有意义的。这就是为什么这些方法是静态的。它们可以在当前正在执行的线程中工作，并避免程序员错误的认为可以在其他非运行线程调用这些方法。

16.如何确保线程安全？
在Java中可以有很多方法来保证线程安全——同步，使用原子类(atomic concurrent classes)，实现并发锁，使用volatile关键字，使用不变类和线程安全类。在线程安全教程中，你可以学到更多。

17. volatile关键字在Java中有什么作用？
当我们使用volatile关键字去修饰变量的时候，所以线程都会直接读取该变量并且不缓存它。这就确保了线程读取到的变量是同内存中是一致的。

18. 同步方法和同步块，哪个是更好的选择？
同步块是更好的选择，因为它不会锁住整个对象（当然你也可以让它锁住整个对象）。同步方法会锁住整个对象，哪怕这个类中有多个不相关联的同步块，这通常会导致他们停止执行并需要等待获得这个对象上的锁。

19.如何创建守护线程？
使用Thread类的setDaemon(true)方法可以将线程设置为守护线程，需要注意的是，需要在调用start()方法前调用这个方法，否则会抛出IllegalThreadStateException异常。

20. 什么是ThreadLocal?
ThreadLocal用于创建线程的本地变量，我们知道一个对象的所有线程会共享它的全局变量，所以这些变量不是线程安全的，我们可以使用同步技术。但是当我们不想使用同步的时候，我们可以选择ThreadLocal变量。

每个线程都会拥有他们自己的Thread变量，它们可以使用get()\set()方法去获取他们的默认值或者在线程内部改变他们的值。ThreadLocal实例通常是希望它们同线程状态关联起来是private static属性。在ThreadLocal例子这篇文章中你可以看到一个关于ThreadLocal的小程序。

21. 什么是Thread Group？为什么建议使用它？
ThreadGroup是一个类，它的目的是提供关于线程组的信息。

ThreadGroup API比较薄弱，它并没有比Thread提供了更多的功能。它有两个主要的功能：一是获取线程组中处于活跃状态线程的列表；二是设置为线程设置未捕获异常处理器(ncaught exception handler)。但在Java 1.5中Thread类也添加了setUncaughtExceptionHandler(UncaughtExceptionHandler eh) 方法，所以ThreadGroup是已经过时的，不建议继续使用。

t1.setUncaughtExceptionHandler(new UncaughtExceptionHandler(){
 
@Override
public void uncaughtException(Thread t, Throwable e) {
System.out.println("exception occured:"+e.getMessage());
}
 
});
22. 什么是Java线程转储(Thread Dump)，如何得到它？
线程转储是一个JVM活动线程的列表，它对于分析系统瓶颈和死锁非常有用。有很多方法可以获取线程转储——使用Profiler，Kill -3命令，jstack工具等等。我更喜欢jstack工具，因为它容易使用并且是JDK自带的。由于它是一个基于终端的工具，所以我们可以编写一些脚本去定时的产生线程转储以待分析。读这篇文档可以了解更多关于产生线程转储的知识。

23. 什么是死锁(Deadlock)？如何分析和避免死锁？
死锁是指两个以上的线程永远阻塞的情况，这种情况产生至少需要两个以上的线程和两个以上的资源。

分析死锁，我们需要查看Java应用程序的线程转储。我们需要找出那些状态为BLOCKED的线程和他们等待的资源。每个资源都有一个唯一的id，用这个id我们可以找出哪些线程已经拥有了它的对象锁。

避免嵌套锁，只在需要的地方使用锁和避免无限期等待是避免死锁的通常办法，阅读这篇文章去学习如何分析死锁。

24. 什么是Java Timer类？如何创建一个有特定时间间隔的任务？
java.util.Timer是一个工具类，可以用于安排一个线程在未来的某个特定时间执行。Timer类可以用安排一次性任务或者周期任务。

java.util.TimerTask是一个实现了Runnable接口的抽象类，我们需要去继承这个类来创建我们自己的定时任务并使用Timer去安排它的执行。

这里有关于java Timer的例子。

25. 什么是线程池？如何创建一个Java线程池？
一个线程池管理了一组工作线程，同时它还包括了一个用于放置等待执行的任务的队列。

java.util.concurrent.Executors提供了一个 java.util.concurrent.Executor接口的实现用于创建线程池。线程池例子展现了如何创建和使用线程池，或者阅读ScheduledThreadPoolExecutor例子，了解如何创建一个周期任务。


1．线程中一些基本术语和概念
1.1线程的几个状态
  初始化状态
  就绪状态
  运行状态
  阻塞状态
  终止状态
1.2 Daemon线程
Daemon线程区别一般线程之处是：主程序一旦结束，Daemon线程就会结束。
1.3锁的定义
为了协调多个并发运行的线程使用共享资源才引入了锁的概念。
1.4死锁
任何多线程应用程序都有死锁风险。当一组线程中的每一个都在等待一个只
有该组中另一个线程才能引起的事件时，我们就说这组线程死锁了。换一个说法
就是一组线程中的每一个成员都在等待别的成员占有的资源时候，就可以说这组
线程进入了死锁。死锁的最简单情形是：线程 A 持有对象 X 的独占锁，并且
在等待对象 Y 的锁，而线程 B 持有对象 Y 的独占锁，却在等待对象 X 的锁。
除非有某种方法来打破对锁的等待（Java 锁定不支持这种方法），否则死锁的线
程将永远等下去。

1.5.Java对象关于锁的几个方法
1.5.1 wait方法
wait方法是java根对象Object含有的方法，表示等待获取某个锁。在wait方法进入前，会释放相应的锁，在wait方法返回时，会再次获得某个锁。
如果wait()方法不带有参数，那只有当持有该对象锁的其他线程调用了notify或者notifyAll方法，才有可能再次获得该对象的锁。
如果wait()方法带有参数，比如：wait(10)，那当持有该对象锁的其他线程调用了notify或者notifyAll方法，或者指定时间已经过去了，才有可能再次获得该对象的锁。
参考 thread.lock.SleepAndWait
1.5.2 notify/notifyAll方法
   这里我就不再说明了。哈哈，偷点懒。
1.5.3 yield方法
yield()会自动放弃CPU，有时比sleep更能提升性能。
1.6锁对象(实例方法的锁)
  在同步代码块中使用锁的时候，担当锁的对象可以是这个代码所在对象本身或者一个单独的对象担任，但是一定要确保锁对象不能为空。如果对一个null对象加锁，会产生异常的。原则上不要选择一个可能在锁的作用域中会改变值的实例变量作为锁对象。
锁对象,一种是对象自己担任，一种是定义一个普通的对象作为private property来担任，另外一种是建立一个新的类，然后用该类的实例来担任。
参考 :
thread.lock.UseSelfAsLock，使用对象自己做锁对象
thread.lock.UseObjAsLock  使用一个实例对象作锁对象
thread.lock.UseAFinalObjAsLock使用常量对象作为一个锁对象
1.7类锁
   实例方法存在同步的问题，同样，类方法也存在需要同步的情形。一般类方法的类锁是一个static object来担任的。当然也可以采用类本身的类对象来作为类锁。
   一个类的实例方法可以获得该类实例锁，还可以尝试去访问类方法，包含类同步方法，去获得类锁。
   一个类的类方法，可以尝试获得类锁，但是不可以尝试直接获得实例锁。需要先生成一个实例，然后在申请获得这个实例的实例锁。
参考
thread.lock.UseStaticObjAsStaticLock 使用类的属性对象作为类锁。
thread.lock.UseClassAsStaticLock使用类的类对象作为类锁

1.8.线程安全方法与线程不安全方法
   如果一个对象的所有的public方法都是同步方法，也就是说是public方法是线程安全的，那该对象的private方法，在不考虑继承的情况下，可以设置为不是线程安全的方法。
   参考 thread.lock.SynMethrodAndNotSynMethrod

1.9类锁和实例锁混合使用
在实例方法中混合使用类锁和实例锁；可以根据前面说的那样使用实例锁和类锁。
在类方法中混合使用类锁和实例锁，可以根据前面说的那样使用类锁，为了使用实例锁，先得生成一个实例，然后实例锁。
参考 thread.lock.StaticLockAndObjLock
1.10锁的粒度问题。
为了解决对象锁的粒度过粗，会导死锁出现的可能性加大，锁的粒度过细，会程序开发维护的工作加大。对于锁的粒度大小，这完全要根据实际开发需要来考虑，很难有一个统一的标准。

1.11.读写锁
一个读写锁支持多个线程同时访问一个对象，但是在同一时刻只有一个线程可以修改此对象，并且在访问进行时不能修改。
有2种调度策略，一种是读锁优先，另外就是写锁优先。
参考 thread.lock.ReadWriteLock
1.12 volatile
在Java中设置变量值的操作，除了long和double类型的变量外都是原子操作，也就是说，对于变量值的简单读写操作没有必要进行同步。这在JVM 1.2之前，Java的内存模型实现总是从主存读取变量，是不需要进行特别的注意的。而随着JVM的成熟和优化，现在在多线程环境下volatile关键字的使用变得非常重要。在当前的Java内存模型下，线程可以把变量保存在本地内存（比如机器的寄存器）中，而不是直接在主存中进行读写。这就可能造成一个线程在主存中修改了一个变量的值，而另外一个线程还继续使用它在寄存器中的变量值的拷贝，造成数据的不一致。要解决这个问题，只需要像在本程序中的这样，把该变量声明为volatile（不稳定的）即可，这就指示JVM，这个变量是不稳定的，每次使用它都到主存中进行读取。一般说来，多任务环境下各任务间共享的标志都应该加volatile修饰。

2．线程之间的通讯
在其他语言中，线程之间可以通过消息队列，共享内存，管道等方式来实现
线程之间的通讯，但是java中可以不采用这样方式，关注的是线程之间的同步。
只要保证相关方法运行的线程安全，信息共享是自然就可以显现了。
2.1屏障
   屏障就是这样的一个等待点: 一组线程在这一点被同步，这些线程合并各自的结果或者运行到整体任务的下一阶段。
   参考：
thread.lock. BarrierUseExample
thread.lock.Barrier
2.2.锁工具类
  提供对线程锁的获取，释放功能。展示了锁的获取释放过程。可以作为一个工具类来使用。
  参考：thread.lock. BusyFlag

2.3.条件变量
条件变量是POSIX线程模型提供的一种同步类型，和java中的等待通知机制类似。
虽然java中已经有了等待通知机制，但是为了减少在notify/notifyAll方法中
线程调度的开销，把一些不需要激活的线程屏蔽出去，引入了条件变量。
    Java中2个（多个）条件变量可以是同一个互斥体（锁对象）。
参考：thread.lock.CondVar  条件变量类
常见的应用情形：
一个锁控制多个信号通道（例如：多个变量），虽然可以采用简单java等待通知机制，但是线程调度效率不高，而且线程可读性也不是太好，这时候可以采用创建一个锁对象(BusyFlag实例)，同时使用这个BusyFlag实例来创建多个条件变量(CondVar 实例)。
经常使用到CondVar类的地方是缓冲区管理，比如：管道操作之类的。先创建一个BusyFlag实例，然后创建CondVar 实例，用这个条件变量描述缓冲区是否为空，另外创建CondVar 实例作条件变量述缓冲区是否满。
   现实中，马路的红绿灯，就可以采用条件变量来描述。

3. Java线程调度
3.1 Java优先级
   java的优先级别共有10种，加上虚拟机自己使用的优先级别=0这种，总共11种。
   大多数情况来说，java线程的优先级设置越高（最高=10），那线程越优先运行。
3.2. 绿色线程
  线程运行在虚拟机内，操作系统根本不知道这类线程的存在。
  线程是由虚拟机调度的。
3.3 本地线程
  线程是由运行虚拟机的操作系统完成的。
3.4 Windows本地线程
   操作系统，完全能够看得到虚拟机内的每一个线程，同时虚拟机的线程和操作系统的线程是一一对应的。Java的线程调度室由操作系统底层线程决定的。
  在win32平台下，windows线程只有6个优先级别。和java线程优先级别对应如下：
Java线程优先级	Windows 95/nt/2000线程优先级
0	THREAD_ PRIORITY_IDLE
1(Thread.MIN_PRIORITY)	THREAD_ PRIORITY_LOWEST
2	THREAD_ PRIORITY_LOWEST
3	THREAD_ PRIORITY_BELOW_NORMAL
4	THREAD_ PRIORITY_BELOW_NORMAL
5 (Thread.NORM_PRIORITY)	THREAD_ PRIORITY _NORMAL
6	THREAD_ PRIORITY _ABOVE_NORMAL
7	THREAD_ PRIORITY _ABOVE_NORMA
8	THREAD_ PRIORITY _HIGHEST
9	THREAD_ PRIORITY _HIGHEST
10 (Thread.MAX_PRIORITY)	THREAD_ PRIORITY _CRITICAL

3.5线程优先级倒置与继承
   如果一个线程持有锁(假设该线程名字=ThreadA,优先级别=5)，另外一个线程(假设该线程名字=ThreadB,优先级别=7),现在该线程(ThreadA)处于运行状态，但是线程ThreadB申请需要持有ThreadA所获得的锁，这时候，为了避免死锁，线程A提高其运行的优先级别（提高到ThreadB的优先级别=7）,而线程ThreadB为了等待获得锁，降低线程优先级别(降低到ThreadA原来的优先级别=5).
   上述的这种情况，对于ThreadA,继承了ThreadB的优先级别，这成为优先级别的继承；对于ThreadB暂时降低了优先级别，成为优先级别的倒置。
   当然，一旦线程ThreadA持有的锁释放了，其优先级别也会回到原来的优先级别（优先级别=5）。线程ThreadB获得了相应的锁，那优先级别也会恢复到与原来的值(优先级别=7)。

3.6循环调度
     具有同样优先级的线程相互抢占成为循环调度。

4.线程池
   创建一个线程也是需要一定代价的,为了降低这个代价，采用了和普通对象池的思想建立线程池，以供系统使用。
线程消耗包括内存和其它系统资源在内的大量资源。除了 Thread 对象所需的内存之外，每个线程都需要两个可能很大的执行调用堆栈。除此以外，JVM 可能会为每个 Java 线程创建一个本机线程，这些本机线程将消耗额外的系统资源。最后，虽然线程之间切换的调度开销很小，但如果有很多线程，环境切换也可能严重地影响程序的性能。
  使用线程池的方式是，先建立对象池，然后申请使用线程，程序线程运行，运行完毕，把线程返回线程池。
使用线程池的风险：同步错误和死锁，与池有关的死锁、资源不足和线程泄漏。
大家有空可以研究一下tomcat的线程池实现原理思想。
实际上是tomcat已经在从线程池的使用线程时候加上了事件处理机制。
个人认为，线程池之类的实现，一般不要自己实现，因为自己实现主要是稳定性等方面可能作的不够好。
可以参考 apache的jakarta-tomcat-5.5.6的相关代码，具体是：
jakarta-tomcat-connectors\util\java\org\apache\tomcat\util\threads的相关代码 


5工作队列
使用工作队列的好处是不象直接使用线程池那样，当线城池中没有线程可以使用的时
候，使用者需要处于等待状态，不能进行其他任务的处理。
工作队列的工作原理是：
采用后台线程处理方式，客户端把任务提交给工作队列，工作队列有一组内部可以工作线程，这些工作线程从工作队列中取出任务运行，一个任务完成后，就从队列获取下一个任务进行处理。当工作队列中没有任务可以处理时候，工作线程就处于等待状态，直到获得新的任务时候，才进行新的处理。
参考：
       thread.workqueue. WorkQueue简单的工作队列类
thread.workqueue. WorkerThread 工作队列内部线程类
带有事件监听功能的队列
thread.workqueue. WorkQueueWithListener
thread.workqueue.WorkerThreadWithListener

20、重载（Overload）和重写（Override）的区别。重载的方法能否根据返回类型进行区分?

答：方法的重载和重写都是实现多态的方式，区别在于前者实现的是编译时的多态性，而后者实现的是运行时的多态性。重载发生在一个类中，同名的方法如果有不同的参数列表（参数类型不同、参数个数不同或者二者都不同）则视为重载；重写发生在子类与父类之间，重写要求子类被重写方法与父类被重写方法有相同的返回类型，比父类被重写方法更好访问，不能比父类被重写方法声明更多的异常（里氏代换原则）。重载对返回类型没有特殊的要求。

 

21、描述一下JVM 加载class文件的原理机制?

答：JVM 中类的装载是由类加载器（ClassLoader） 和它的子类来实现的,Java中的类加载器是一个重要的Java 运行时系统组件，它负责在运行时查找和装入类文件中的类。
补充：

1.由于Java的跨平台性，经过编译的Java源程序并不是一个可执行程序，而是一个或多个类文件。当Java程序需要使用某个类时，JVM会确保这个类已经被加载、连接(验证、准备和解析)和初始化。类的加载是指把类的.class文件中的数据读入到内存中，通常是创建一个字节数组读入.class文件，然后产生与所加载类对应的Class对象。加载完成后，Class对象还不完整，所以此时的类还不可用。当类被加载后就进入连接阶段，这一阶段包括验证、准备(为静态变量分配内存并设置默认的初始值)和解析(将符号引用替换为直接引用)三个步骤。最后JVM对类进行初始化，包括：1如果类存在直接的父类并且这个类还没有被初始化，那么就先初始化父类；2如果类中存在初始化语句，就依次执行这些初始化语句。
2.类的加载是由类加载器完成的，类加载器包括：根加载器（BootStrap）、扩展加载器（Extension）、系统加载器（System）和用户自定义类加载器（java.lang.ClassLoader的子类）。从JDK 1.2开始，类加载过程采取了父亲委托机制(PDM)。PDM更好的保证了Java平台的安全性，在该机制中，JVM自带的Bootstrap是根加载器，其他的加载器都有且仅有一个父类加载器。类的加载首先请求父类加载器加载，父类加载器无能为力时才由其子类加载器自行加载。JVM不会向Java程序提供对Bootstrap的引用。下面是关于几个类加载器的说明：
a)Bootstrap：一般用本地代码实现，负责加载JVM基础核心类库（rt.jar）；
b)Extension：从java.ext.dirs系统属性所指定的目录中加载类库，它的父加载器是Bootstrap；
c)System：又叫应用类加载器，其父类是Extension。它是应用最广泛的类加载器。它从环境变量classpath或者系统属性java.class.path所指定的目录中记载类，是用户自定义加载器的默认父加载器。

30、GC 是什么？为什么要有GC？

答：GC是垃圾收集的意思，内存处理是编程人员容易出现问题的地方，忘记或者错误的内存回收会导致程序或系统的不稳定甚至崩溃，Java提供的GC功能可以自动监测对象是否超过作用域从而达到自动回收内存的目的，Java语言没有提供释放已分配内存的显示操作方法。Java程序员不用担心内存管理，因为垃圾收集器会自动进行管理。要请求垃圾收集，可以调用下面的方法之一：System.gc() 或Runtime.getRuntime().gc() 。
垃圾回收可以有效的防止内存泄露，有效的使用可以使用的内存。垃圾回收器通常是作为一个单独的低优先级的线程运行，不可预知的情况下对内存堆中已经死亡的或者长时间没有使用的对象进行清除和回收，程序员不能实时的调用垃圾回收器对某个对象或所有对象进行垃圾回收。回收机制有分代复制垃圾回收、标记垃圾回收、增量垃圾回收等方式。
补充：标准的Java进程既有栈又有堆。栈保存了原始型局部变量，堆保存了要创建的对象。Java平台对堆内存回收和再利用的基本算法被称为标记和清除，但是Java对其进行了改进，采用“分代式垃圾收集”。这种方法会跟Java对象的生命周期将堆内存划分为不同的区域，在垃圾收集过程中，可能会将对象移动到不同区域：
² 伊甸园（Eden）：这是对象最初诞生的区域，并且对大多数对象来说，这里是它们唯一存在过的区域。
² 幸存者乐园（Survivor）：从伊甸园幸存下来的对象会被挪到这里。
² 终身颐养园（Tenured）：这是足够老的幸存对象的归宿。年轻代收集（Minor-GC）过程是不会触及这个地方的。当年轻代收集不能把对象放进终身颐养园时，就会触发一次完全收集（Major-GC），这里可能还会牵扯到压缩，以便为大对象腾出足够的空间。
与垃圾回收相关的JVM参数：
² -Xms / -Xmx --- 堆的初始大小 / 堆的最大大小
² -Xmn --- 堆中年轻代的大小
² -XX:-DisableExplicitGC --- 让System.gc()不产生任何作用
² -XX:+PrintGCDetail --- 打印GC的细节
-XX:+PrintGCDateStamps --- 打印GC操作的时间戳

37、指出下面程序的运行结果:

class A{

static{

System.out.print("1");

}

public A(){

System.out.print("2");

}

}

class B extends A{

static{

System.out.print("a");

}

public B(){

System.out.print("b");

}

}

public class Hello{

public static void main(String[] ars){

A ab = new B();

ab = new B();

}

}
答：执行结果：1a2b2b。创建对象时构造器的调用顺序是：先初始化静态成员，然后调用父类构造器，再初始化非静态成员，最后调用自身构造器。
理论计算机科学中，CAP定理（CAP theorem），又被称作布鲁尔定理（Brewer's theorem），它指出对于一个分布式计算系统来说，不可能同时满足以下三点：[1][2]
一致性（Consistence) (等同于所有节点访问同一份最新的数据副本）
可用性（Availability）（对数据更新具备高可用性）
容忍网络分区（Partition tolerance）（以实际效果而言，分区相当于对通信的时限要求。系统如果不能在时限内达成数据一致性，就意味着发生了分区的情况，必须就当前操作在C和A之间做出选择[3]。）
根据定理，分布式系统只能满足三项中的两项而不可能满足全部三项[4]。理解CAP理论的最简单方式是想象两个节点分处分区两侧。允许至少一个节点更新状态会导致数据不一致，即丧失了C性质。如果为了保证数据一致性，将分区一侧的节点设置为不可用，那么又丧失了A性质。除非两个节点可以互相通信，才能既保证C又保证A，这又会导致丧失P性质。


Redis 还可以通过乐观锁（optimistic lock）实现 CAS （check-and-set）操作
过滤器（filter），过滤器处于客户端与Web资源（Servlet、JSP、HTML）之间，客户端与Web资源之间的请求和响应都要通过过滤器进行过滤。举例：在过滤器中定义了禁止访问192.10.10.1这个地址，那么当客户端发出访问192.10.10.1的请求时，经过过滤器后，客户端得到的响应是出现该IP禁止访问的提示。在java web中，你传入的request,response提前过滤掉一些信息，或者提前设置一些参数，然后再传入servlet或者struts的 action进行业务逻辑，比如过滤掉非法url（不是login.do的地址请求，如果用户没有登陆都过滤掉）,或者在传入servlet或者 struts的action前统一设置字符集，或者去除掉一些非法字符 

      拦截器（interceptor），拦截器是一种面向方面/切面编程（AOP Aspect-Oriented Programming），而面向切面就是将多个模块的的通用服务进行分离，如权限管理、日志服务，他们在多个模块中都会用到，就可以将其各自封装为一个可重用模块。而这些通用服务的具体实现是通过拦截器来完成，比如用户客户端访问一些保密模块都应先通过权限审查的拦截器来进行权限审查，确定用户是否具有该项操作的权限后方能向下执行。在面向切面编程的就是在你的service或者一个方法，前调用一个方法，或者在方法后调用一个方法比如动态代理就是拦截器的简单实现，在你调用方法前打印出字符串（或者做其它业务逻辑的操作），也可以在你调用方法后打印出字符串，甚至在你抛出异常的时候做业务逻辑的操作。 

拦截器与过滤器的区别 ： 

1、拦截器是基于java的反射机制的，而过滤器是基于函数回调 

2、过滤器依赖与servlet容器，而拦截器不依赖与servlet容器 

3、拦截器只能对action请求起作用，而过滤器则可以对几乎所有的请求起作用 

4、拦截器可以访问action上下文、值栈里的对象，而过滤器不能 

5、在action的生命周期中，拦截器可以多次被调用，而过滤器只能在容器初始化时被调用一次 



执行顺序 ：过滤前 - 拦截前 - Action处理 - 拦截后 - 过滤后。个人认为过滤是一个横向的过程，首先把客户端提交的内容进行过滤(例如未登录用户不能访问内部页面的处理)；过滤通过后，拦截器将检查用户提交数据的验证，做一些前期的数据处理，接着把处理后的数据发给对应的Action；Action处理完成返回后，拦截器还可以做其他过程(还没想到要做啥)，再向上返回到过滤器的后续操作。 



详细说明 ： 

拦截器 ：是在面向切面编程的就是在你的service或者一个方法前调用一个方法，或者在方法后调用一个方法比如动态代理就是拦截器的简单实现，在你调用方法前打印出字符串（或者做其它业务逻辑的操作），也可以在你调用方法后打印出字符串，甚至在你抛出异常的时候做业务逻辑的操作。 


目录

Spring概述

依赖注入

Spring Beans

Spring注解

Spring的对象访问

Spring面向切面编程

Spring MVC框架

Spring概述

1.什么是Spring？

Spring是一个开源的Java EE开发框架。Spring框架的核心功能可以应用在任何Java应用程序中，但对Java EE平台上的Web应用程序有更好的扩展性。Spring框架的目标是使得Java EE应用程序的开发更加简捷，通过使用POJO为基础的编程模型促进良好的编程风格。

2.Spring有哪些优点？

轻量级：Spring在大小和透明性方面绝对属于轻量级的，基础版本的Spring框架大约只有2MB。

控制反转(IOC)：Spring使用控制反转技术实现了松耦合。依赖被注入到对象，而不是创建或寻找依赖对象。

面向切面编程(AOP)： Spring支持面向切面编程，同时把应用的业务逻辑与系统的服务分离开来。

容器：Spring包含并管理应用程序对象的配置及生命周期。

MVC框架：Spring的web框架是一个设计优良的web MVC框架，很好的取代了一些web框架。

事务管理：Spring对下至本地业务上至全局业务(JAT)提供了统一的事务管理接口。

异常处理：Spring提供一个方便的API将特定技术的异常(由JDBC, Hibernate, 或JDO抛出)转化为一致的、Unchecked异常。

3.Spring框架有哪些模块？

Spring框架的基本模块如下所示：

Core module
Bean module
Context module
Expression Language module
JDBC module
ORM module
OXM module
Java Messaging Service(JMS) module
Transaction module
Web module
Web-Servlet module
Web-Struts module
Web-Portlet module
4.解释核心容器(应用上下文)模块

这是Spring的基本模块，它提供了Spring框架的基本功能。BeanFactory 是所有Spring应用的核心。Spring框架是建立在这个模块之上的，这也使得Spring成为一个容器。

5.BeanFactory – BeanFactory 实例

BeanFactory是工厂模式的一种实现，它使用控制反转将应用的配置和依赖与实际的应用代码分离开来。

最常用的BeanFactory实现是XmlBeanFactory类。

6.XmlBeanFactory

最常用的就是org.springframework.beans.factory.xml.XmlBeanFactory，它根据XML文件中定义的内容加载beans。该容器从XML文件中读取配置元数据，并用它来创建一个完备的系统或应用。

7.解释AOP模块

AOP模块用来开发Spring应用程序中具有切面性质的部分。该模块的大部分服务由AOP Aliance提供，这就保证了Spring框架和其他AOP框架之间的互操作性。另外，该模块将元数据编程引入到了Spring。

8.解释抽象JDBC和DAO模块

通过使用抽象JDBC和DAO模块保证了与数据库连接代码的整洁与简单，同时避免了由于未能关闭数据库资源引起的问题。它在多种数据库服务器的错误信息之上提供了一个很重要的异常层。它还利用Spring的AOP模块为Spring应用程序中的对象提供事务管理服务。

9.解释对象/关系映射集成模块

Spring通过提供ORM模块在JDBC的基础上支持对象关系映射工具。这样的支持使得Spring可以集成主流的ORM框架，包括Hibernate, JDO, 及iBATIS SQL Maps。Spring的事务管理可以同时支持以上某种框架和JDBC。

10.解释web模块

Spring的web模块建立在应用上下文(application context)模块之上，提供了一个适合基于web应用程序的上下文环境。该模块还支持了几个面向web的任务，如透明的处理多文件上传请求及将请求参数同业务对象绑定起来。

11.解释Spring MVC模块

Spring提供MVC框架构建web应用程序。Spring可以很轻松的同其他MVC框架结合，但Spring的MVC是个更好的选择，因为它通过控制反转将控制逻辑和业务对象完全分离开来。

12.Spring的配置文件

Spring的配置文件是一个XML文件，文件包含了类信息并描述了这些类是如何配置和互相调用的。

13.Spring IoC容器是什么？

Spring IOC负责创建对象、管理对象(通过依赖注入)、整合对象、配置对象以及管理这些对象的生命周期。

14.IOC有什么优点？

IOC或依赖注入减少了应用程序的代码量。它使得应用程序的测试很简单，因为在单元测试中不再需要单例或JNDI查找机制。简单的实现以及较少的干扰机制使得松耦合得以实现。IOC容器支持勤性单例及延迟加载服务。

15.应用上下文是如何实现的？

FileSystemXmlApplicationContext 容器加载XML文件中beans的定义。XML Bean配置文件的完整路径必须传递给构造器。

FileSystemXmlApplicationContext 容器也加载XML文件中beans的定义。注意，你需要正确的设置CLASSPATH，因为该容器会在CLASSPATH中查看bean的XML配置文件。

WebXmlApplicationContext：该容器加载xml文件，这些文件定义了web应用中所有的beans。

16.Bean Factory和ApplicationContext有什么区别？

ApplicationContext提供了一种解决文档信息的方法，一种加载文件资源的方式(如图片)，他们可以向监听他们的beans发送消息。另外，容器或者容器中beans的操作，这些必须以bean工厂的编程方式处理的操作可以在应用上下文中以声明的方式处理。应用上下文实现了MessageSource，该接口用于获取本地消息，实际的实现是可选的。

17.Spring应用程序看起来像什么？

一个定义功能的接口
实现包括属性，setter和getter方法，功能等
Spring AOP
Spring的XML配置文件
使用该功能的客户端编程
依赖注入

18.Spring中的依赖注入是什么？

依赖注入作为控制反转(IOC)的一个层面，可以有多种解释方式。在这个概念中，你不用创建对象而只需要描述如何创建它们。你不必通过代码直接的将组件和服务连接在一起，而是通过配置文件说明哪些组件需要什么服务。之后IOC容器负责衔接。

19.有哪些不同类型的IOC(依赖注入)？

构造器依赖注入：构造器依赖注入在容器触发构造器的时候完成，该构造器有一系列的参数，每个参数代表注入的对象。

Setter方法依赖注入：首先容器会触发一个无参构造函数或无参静态工厂方法实例化对象，之后容器调用bean中的setter方法完成Setter方法依赖注入。

20.你推荐哪种依赖注入？构造器依赖注入还是Setter方法依赖注入？

你可以同时使用两种方式的依赖注入，最好的选择是使用构造器参数实现强制依赖注入，使用setter方法实现可选的依赖关系。

Spring Beans

21.什么是Spring Beans？

Spring Beans是构成Spring应用核心的Java对象。这些对象由Spring IOC容器实例化、组装、管理。这些对象通过容器中配置的元数据创建，例如，使用XML文件中定义的创建。

在Spring中创建的beans都是单例的beans。在bean标签中有一个属性为”singleton”,如果设为true，该bean是单例的，如果设为false，该bean是原型bean。Singleton属性默认设置为true。因此，spring框架中所有的bean都默认为单例bean。

22.Spring Bean中定义了什么内容？

Spring Bean中定义了所有的配置元数据，这些配置信息告知容器如何创建它，它的生命周期是什么以及它的依赖关系。

23.如何向Spring 容器提供配置元数据？

有三种方式向Spring 容器提供元数据:

XML配置文件

基于注解配置

基于Java的配置

24.你如何定义bean的作用域？

在Spring中创建一个bean的时候，我们可以声明它的作用域。只需要在bean定义的时候通过’scope’属性定义即可。例如，当Spring需要产生每次一个新的bean实例时，应该声明bean的scope属性为prototype。如果每次你希望Spring返回一个实例，应该声明bean的scope属性为singleton。

25.说一下Spring中支持的bean作用域

Spring框架支持如下五种不同的作用域：

singleton：在Spring IOC容器中仅存在一个Bean实例，Bean以单实例的方式存在。

prototype：一个bean可以定义多个实例。

request：每次HTTP请求都会创建一个新的Bean。该作用域仅适用于WebApplicationContext环境。

session：一个HTTP Session定义一个Bean。该作用域仅适用于WebApplicationContext环境.

globalSession：同一个全局HTTP Session定义一个Bean。该作用域同样仅适用于WebApplicationContext环境.

bean默认的scope属性是’singleton‘。

26.Spring框架中单例beans是线程安全的吗？

不是，Spring框架中的单例beans不是线程安全的。

27.解释Spring框架中bean的生命周期

Spring容器读取XML文件中bean的定义并实例化bean。

Spring根据bean的定义设置属性值。

如果该Bean实现了BeanNameAware接口，Spring将bean的id传递给setBeanName()方法。

如果该Bean实现了BeanFactoryAware接口，Spring将beanfactory传递给setBeanFactory()方法。

如果任何bean BeanPostProcessors 和该bean相关，Spring调用postProcessBeforeInitialization()方法。

如果该Bean实现了InitializingBean接口，调用Bean中的afterPropertiesSet方法。如果bean有初始化函数声明，调用相应的初始化方法。

如果任何bean BeanPostProcessors 和该bean相关，调用postProcessAfterInitialization()方法。

如果该bean实现了DisposableBean，调用destroy()方法。

28.哪些是最重要的bean生命周期方法？能重写它们吗？

有两个重要的bean生命周期方法。第一个是setup方法，该方法在容器加载bean的时候被调用。第二个是teardown方法，该方法在bean从容器中移除的时候调用。

bean标签有两个重要的属性(init-method 和 destroy-method)，你可以通过这两个属性定义自己的初始化方法和析构方法。Spring也有相应的注解：@PostConstruct 和 @PreDestroy。

29.什么是Spring的内部bean？

当一个bean被用作另一个bean的属性时，这个bean可以被声明为内部bean。在基于XML的配置元数据中，可以通过把元素定义在 或元素内部实现定义内部bean。内部bean总是匿名的并且它们的scope总是prototype。

30.如何在Spring中注入Java集合类？

Spring提供如下几种类型的集合配置元素：

list元素用来注入一系列的值，允许有相同的值。

set元素用来注入一些列的值，不允许有相同的值。

map用来注入一组”键-值”对，键、值可以是任何类型的。

props也可以用来注入一组”键-值”对，这里的键、值都字符串类型。

31.什么是bean wiring？

Wiring，或者说bean Wiring是指beans在Spring容器中结合在一起的情况。当装配bean的时候，Spring容器需要知道需要哪些beans以及如何使用依赖注入将它们结合起来。

32.什么是bean自动装配？

Spring容器可以自动配置相互协作beans之间的关联关系。这意味着Spring可以自动配置一个bean和其他协作bean之间的关系，通过检查BeanFactory 的内容里没有使用和< property>元素。

33.解释自动装配的各种模式？

自动装配提供五种不同的模式供Spring容器用来自动装配beans之间的依赖注入:

no：默认的方式是不进行自动装配，通过手工设置ref 属性来进行装配bean。

byName：通过参数名自动装配，Spring容器查找beans的属性，这些beans在XML配置文件中被设置为byName。之后容器试图匹配、装配和该bean的属性具有相同名字的bean。

byType：通过参数的数据类型自动自动装配，Spring容器查找beans的属性，这些beans在XML配置文件中被设置为byType。之后容器试图匹配和装配和该bean的属性类型一样的bean。如果有多个bean符合条件，则抛出错误。

constructor：这个同byType类似，不过是应用于构造函数的参数。如果在BeanFactory中不是恰好有一个bean与构造函数参数相同类型，则抛出一个严重的错误。

autodetect：如果有默认的构造方法，通过 construct的方式自动装配，否则使用 byType的方式自动装配。

34.自动装配有哪些局限性？

自动装配有如下局限性：

重写：你仍然需要使用 和< property>设置指明依赖，这意味着总要重写自动装配。

原生数据类型:你不能自动装配简单的属性，如原生类型、字符串和类。

模糊特性：自动装配总是没有自定义装配精确，因此，如果可能尽量使用自定义装配。

35.你可以在Spring中注入null或空字符串吗？

完全可以。

Spring注解

36.什么是Spring基于Java的配置？给出一些注解的例子

基于Java的配置允许你使用Java的注解进行Spring的大部分配置而非通过传统的XML文件配置。

以注解@Configuration为例，它用来标记类，说明作为beans的定义，可以被Spring IOC容器使用。另一个例子是@Bean注解，它表示该方法定义的Bean要被注册进Spring应用上下文中。

37.什么是基于注解的容器配置?

另外一种替代XML配置的方式为基于注解的配置，这种方式通过字节元数据装配组件而非使用尖括号声明。开发人员将直接在类中进行配置，通过注解标记相关的类、方法或字段声明，而不再使用XML描述bean之间的连线关系。

38.如何开启注解装配？

注解装配默认情况下在Spring容器中是不开启的。如果想要开启基于注解的装配只需在Spring配置文件中配置元素即可。

39.@Required 注解

@Required表明bean的属性必须在配置时设置，可以在bean的定义中明确指定也可通过自动装配设置。如果bean的属性未设置，则抛出BeanInitializationException异常。

40.@Autowired 注解

@Autowired 注解提供更加精细的控制，包括自动装配在何处完成以及如何完成。它可以像@Required一样自动装配setter方法、构造器、属性或者具有任意名称和/或多个参数的PN方法。

41. @Qualifier 注解

当有多个相同类型的bean而只有其中的一个需要自动装配时，将@Qualifier 注解和@Autowire 注解结合使用消除这种混淆，指明需要装配的bean。

Spring数据访问

42.在Spring框架中如何更有效的使用JDBC？

使用Spring JDBC框架，资源管理以及错误处理的代价都会减轻。开发人员只需通过statements和queries语句从数据库中存取数据。Spring框架中通过使用模板类能更有效的使用JDBC，也就是所谓的JdbcTemplate(例子)。

43.JdbcTemplate

JdbcTemplate类提供了许多方法，为我们与数据库的交互提供了便利。例如，它可以将数据库的数据转化为原生类型或对象，执行写好的或可调用的数据库操作语句，提供自定义的数据库错误处理功能。

44.Spring对DAO的支持

Spring对数据访问对象(DAO)的支持旨在使它可以与数据访问技术(如 JDBC, Hibernate 及JDO)方便的结合起来工作。这使得我们可以很容易在的不同的持久层技术间切换，编码时也无需担心会抛出特定技术的异常。

45.使用Spring可以通过什么方式访问Hibernate？

使用Spring有两种方式访问Hibernate：

使用Hibernate Template的反转控制以及回调方法

继承HibernateDAOSupport，并申请一个AOP拦截器节点

46.Spring支持的ORM

Spring支持一下ORM：

Hibernate
iBatis
JPA (Java -Persistence API)
TopLink
JDO (Java Data Objects)
OJB
47.如何通过HibernateDaoSupport将Spring和Hibernate结合起来？

使用Spring的SessionFactory 调用LocalSessionFactory。结合过程分为以下三步：

配置Hibernate SessionFactory

继承HibernateDaoSupport实现一个DAO

使用AOP装载事务支持

48.Spring支持的事务管理类型

Spring支持如下两种方式的事务管理：

编程式事务管理：这意味着你可以通过编程的方式管理事务，这种方式带来了很大的灵活性，但很难维护。

声明式事务管理：这种方式意味着你可以将事务管理和业务代码分离。你只需要通过注解或者XML配置管理事务。

49.Spring框架的事务管理有哪些优点？

它为不同的事务API(如JTA, JDBC, Hibernate, JPA, 和JDO)提供了统一的编程模型。

它为编程式事务管理提供了一个简单的API而非一系列复杂的事务API(如JTA).

它支持声明式事务管理。

它可以和Spring 的多种数据访问技术很好的融合。

50.你更推荐那种类型的事务管理？

许多Spring框架的用户选择声明式事务管理，因为这种方式和应用程序的关联较少，因此更加符合轻量级容器的概念。声明式事务管理要优于编程式事务管理，尽管在灵活性方面它弱于编程式事务管理(这种方式允许你通过代码控制业务)。

Spring面向切面编程(AOP)

51.解释AOP

面向切面编程,或AOP允许程序员模块化横向业务逻辑，或定义核心部分的功能，例如日志管理和事务管理。

52.切面(Aspect)

AOP的核心就是切面，它将多个类的通用行为封装为可重用的模块。该模块含有一组API提供 cross-cutting功能。例如,日志模块称为日志的AOP切面。根据需求的不同，一个应用程序可以有若干切面。在Spring AOP中，切面通过带有@Aspect注解的类实现。

53.在Spring AOP中concern和 cross-cutting concern的区别是什么？

Concern(核心逻辑)：表示在应用程序中一个模块的行为。Concern可以定义为我们想要实现的功能。

Cross-cutting concern(横向的通用逻辑)：指的是整个应用程序都会用到的功能，它影响整个应用程序。例如，日志管理（Logging）、安全管理（Security）以及数据交互是应用程序的每个模块都要涉及到的，因此这些都属于Cross-cutting concern。

54.连接点(Join point)

连接点代表应用程序中插入AOP切面的地点。它实际上是Spring AOP框架在应用程序中执行动作的地点。

55.通知(Advice)

通知表示在方法执行前后需要执行的动作。实际上它是Spring AOP框架在程序执行过程中触发的一些代码。

Spring切面可以执行一下五种类型的通知:

before(前置通知)：在一个方法之前执行的通知。

after(最终通知)：当某连接点退出的时候执行的通知（不论是正常返回还是异常退出）。

after-returning(后置通知)：在某连接点正常完成后执行的通知。

after-throwing(异常通知)：在方法抛出异常退出时执行的通知。

around(环绕通知)：在方法调用前后触发的通知。

56.切入点(Pointcut)

切入点是一个或一组连接点，通知将在这些位置执行。可以通过表达式或匹配的方式指明切入点。

57.什么是引入？

引入允许我们在已有的类上添加新的方法或属性。

58.什么是目标对象？

被一个或者多个切面所通知的对象。它通常是一个代理对象。也被称做被通知（advised）对象。

59.什么是代理？

代理是将通知应用到目标对象后创建的对象。从客户端的角度看，代理对象和目标对象是一样的。

60.有几种不同类型的自动代理？

BeanNameAutoProxyCreator：bean名称自动代理创建器

DefaultAdvisorAutoProxyCreator：默认通知者自动代理创建器

Metadata autoproxying：元数据自动代理

61.什么是织入？什么是织入应用的不同点？

织入是将切面和其他应用类型或对象连接起来创建一个通知对象的过程。织入可以在编译、加载或运行时完成。

62.解释基于XML Schema方式的切面实现

在这种情况下，切面由使用XML文件配置的类实现。

63.解释基于注解方式(基于@AspectJ)的切面实现

在这种情况下(基于@AspectJ的实现)，指的是切面的对应的类使用Java 5注解的声明方式。

Spring的MVC框架

64.什么是Spring的MVC框架？

Spring提供了一个功能齐全的MVC框架用于构建Web应用程序。Spring框架可以很容易的和其他的MVC框架融合(如Struts)，该框架使用控制反转(IOC)将控制器逻辑和业务对象分离开来。它也允许以声明的方式绑定请求参数到业务对象上。

65.DispatcherServlet

Spring的MVC框架围绕DispatcherServlet来设计的，它用来处理所有的HTTP请求和响应。

66.WebApplicationContext

WebApplicationContext继承了ApplicationContext，并添加了一些web应用程序需要的功能。和普通的ApplicationContext 不同，WebApplicationContext可以用来处理主题样式，它也知道如何找到相应的servlet。

67.什么是Spring MVC框架的控制器？

控制器提供对应用程序行为的访问，通常通过服务接口实现。控制器解析用户的输入，并将其转换为一个由视图呈现给用户的模型。Spring 通过一种极其抽象的方式实现控制器，它允许用户创建多种类型的控制器。

68.@Controller annotation

@Controller注解表示该类扮演控制器的角色。Spring不需要继承任何控制器基类或应用Servlet API。

69.@RequestMapping annotation

@RequestMapping注解用于将URL映射到任何一个类或者一个特定的处理方法上。


这个是之前处理过的一个线上问题，处理过程断断续续，经历了两周多的时间，中间各种尝试，总结如下。这篇文章分三部分：
1、问题的场景和处理过程；2、GC的一些理论东西；3、看懂GC的日志
先说一下问题吧
问题场景：线上机器在半夜会推送一个700M左右的数据，这个时候有个数据置换的过程，也就是说有700M*2的数据在heap区域中，线上系统超时比较多，导致了很严重（严重程度就不说了）的问题。
问题原因：看日志，系统接口超时的时候，系统出现了FullGC，这个时候stop-the-world了，也就停机了。分析gc的日志，发现有promotion failed，根据FullGC触发的条件，这个时候就会出现FullGC了。日志如下：
1
2
2013-11-27T03:00:53.638+0800: 35333.562: [GC 35333.562: [ParNew (promotion failed): 1877376K->1877376K(1877376K), 15.7989680 secs]35349.361: [CMS: 2144171K->2129287K(2146304K), 10.4200280 sec
s] 3514052K->2129287K(4023680K), [CMS Perm : 119979K->118652K(190132K)], 26.2193500 secs] [Times: user=30.35 sys=5.19, real=26.22 secs]
问题解决：中间调整过几次，先搞了几台机器做了验证，后来逐步推广的。
1、调大heap区，由原来的4g，调整到5g，young区的大小不变，还是2g，这时候old区就由2g变为3g了（这样保证old区有足够的空间）；
2、设置-XX：UseCMSInitiatingOccupancyOnly，其实这个不关这个问题，只是发现半夜CMS进行的有点频繁，就禁止掉了悲观策略；
3、设置CMS区回收的比例，从80%调整到75%，让old区尽早的进行，有足够的空间剩余；
 
为什么要有GC（垃圾回收）？
JVM通过GC来回收堆和方法区中的内存，GC的基本原理就是找到程序中不再被使用的对象，然后回收掉这些对象占用的内存。
 
主要的收集器有哪些？
引用计数器和跟踪计数器两种。
引用计数器记录对象是否被引用，当计数器为零时，说明对象已经不再被使用，可以进行回收。java中的对象有复杂的引用关系，不是很适合引用计数器，所以sun jdk中并没有实现这种GC方式。
跟踪收集器，全局记录数据的引用状态，基于一定的条件触发。执行的时候，从根集合开始扫描对象的引用关系，主要有复制（copying）、标记-清除（Mark-Sweep）、标记-压缩(Mark-Compact)那种算法。
 
跟踪计数器的三种算法简介？
复制：从根集合搜扫描出存活的对象，然后将存活的对象复制到一块新的未使用的空间中，当要回收的空间中存活的对象较少时，比较高效；
标记清除：从根集合开始扫描，对存活的对象进行标记，比较完毕后，再扫描整个空间中未标记的对象，然后进行回收，不需要对对象进行移动；
标记压缩：标记形式和“标记清除”一样，但是回收不存活的对象后，会把所有存活的对象在内存空间中进行移动，好处是减少了内存碎片，缺点是成本比较高；
 
java内存区域的形式是啥样的？
这里就不再介绍了，之前有一篇文章中专门介绍这个的（http://iamzhongyong.iteye.com/blog/1333100）。
 
新生代可用的GC？
新生代中对象存活的时间比较短，因此给予Copying算法实现，Eden区域存放新创建的对象，S0和S1区其中一块用于存放在Minor GC的时候作为复制存活对象的目标空间，另外一块清空。
串行GC（Serial GC）比较适合单CPU的情况，可以通过-XX：UseSerialGC来强行制定；
并行回收GC（Parallel Scavenge），启动的时候按照设置的参数来划定Eden/S0/S1区域的大小，但是在运行时，会根据Minor GC的频率、消耗时间来动态调整三个区域的大小，可以用过-XX：UseAdaptiveSizePolicy来固定大小，不进行动态调整；
并行GC（ParNew）划分Eden、S1、S0的区域上和串行GC一样。并行GC需要配合旧生代使用CMS GC（这是他和并行回收GC的不同）（如果配置了CMS GC的方式，那么新生代默认采取的就是并行GC的方式）；
 
啥时候会触发Minor GC？
当Eden区域分配内存时，发现空间不足，JVM就会触发Minor GC，程序中System.gc()也可以来触发。
 
旧生代可用的GC方式有哪几种？
串行GC（Serial MSC）、并行GC（Parallel MSC）、并发GC（CMS）；
 
关于CMS？
采用CMS时候，新生代必须使用Serial GC或者ParNew GC两种。CMS共有七个步骤，只有Initial Marking和Final Marking两个阶段是stop-the-world的，其他步骤均和应用并行进行。持久代的GC也采用CMS，通过-XX：CMSPermGenSweepingEnabled -XX：CMSClassUnloadingEnabled来制定。在采用cms gc的情况下，ygc变慢的原因通常是由于old gen出现了大量的碎片。
 
为啥CMS会有内存碎片，如何避免？
由于在CMS的回收步骤中，没有对内存进行压缩，所以会有内存碎片出现，CMS提供了一个整理碎片的功能，通过-XX：UseCompactAtFullCollection来启动此功能，启动这个功能后，默认每次执行Full GC的时候会进行整理（也可以通过-XX：CMSFullGCsBeforeCompaction=n来制定多少次Full GC之后来执行整理），整理碎片会stop-the-world.
 
啥时候会触发CMS GC？
1、旧生代或者持久代已经使用的空间达到设定的百分比时（CMSInitiatingOccupancyFraction这个设置old区，perm区也可以设置）；
2、JVM自动触发(JVM的动态策略，也就是悲观策略)（基于之前GC的频率以及旧生代的增长趋势来评估决定什么时候开始执行），如果不希望JVM自行决定，可以通过-XX：UseCMSInitiatingOccupancyOnly=true来制定；
3、设置了 -XX：CMSClassUnloadingE考虑nabled 这个则考虑Perm区；
 
啥时候会触发Full GC？
一、旧生代空间不足：java.lang.outOfMemoryError：java heap space；
二、Perm空间满：java.lang.outOfMemoryError：PermGen space；
三、CMS GC时出现promotion failed  和concurrent  mode failure（Concurrent mode failure发生的原因一般是CMS正在进行，但是由于old区内存不足，需要尽快回收old区里面的死的java对象，这个时候foreground gc需要被触发，停止所有的java线程，同时终止CMS，直接进行MSC。）；
四、统计得到的minor GC晋升到旧生代的平均大小大于旧生代的剩余空间；
五、主动触发Full GC（执行jmap -histo:live [pid]）来避免碎片问题；
 
为啥heap小于3g不建议使用CMS GC这种方式？
http://hellojava.info/?p=142 毕大师的这篇文章讲的很清楚。
1、触发比例不好设置，设置大了，那么剩余的空间就少了很多，设置小了，那old区还没放置多少东西，就要进行回收了；
2、CMS进行的时候，是并行的，也就意味着如果过于频繁的话，会和应用的强占CPU；
3、CMS会有内存 碎片问题；
4、YGC的速率变慢（由于CMS GC的实现原理，导致对象从新生代晋升到旧生代时，寻找哪里能放下的这个步骤比ParallelOld GC是慢一些的，因此就导致了YGC速度会有一定程度的下降。）；
 
JVM的悲观策略是啥？
所谓的悲观策略（http://tmalltesting.com/archives/663 我们性能测试团队一个同学分析的案例），就是JVM不按照JVM指定的参数来进行CMS GC，而是根据内存情况以及之前回收的方式动态调整，自行进行GC。旧生代剩余的空间（available）大于新生代中使用的空间（max_promotion_in_bytes），或者大于之前平均晋升的old的大小（av_promo），返回false。cms gc是每隔一个周期（默认2s）就会做一次这个检查，如果为false，则不执行YGC，而触发cms gc。
 
我们经常使用的是啥GC方式？
针对目前线上机器的情况（8G的物流内存），heap区一般设置在4g或者5g左右，一般是使用CMS GC，这时候：
young区使用ParNew（并行GC），Old+Perm(需要单独设置)使用CMS，整个堆（young+old+perm）使用MSC（（Mark Sweep Compact）是CMS GC算法的Full GC算法,单线程回收整个堆，回收过程有严格的步骤。压缩，所以回收完理论上任何Generation都不会有内存碎片）压缩回收的方式。
 
读懂GC日志？
基本上都是这种格式：回收前区域占用的大小->回收后区域占用的大小（区域设置的大小），占用的时间
 
1、promotion failed的一段日志
1
2
2013-11-27T03:00:53.638+0800: 35333.562: [GC 35333.562: [ParNew (promotion failed): 1877376K->1877376K(1877376K), 15.7989680 secs]35349.361: [CMS: 2144171K->2129287K(2146304K), 10.4200280 sec
s] 3514052K->2129287K(4023680K), [CMS Perm : 119979K->118652K(190132K)], 26.2193500 secs] [Times: user=30.35 sys=5.19, real=26.22 secs]
解释如下：
1877376K->1877376K(1877376K), 15.7989680 secs   young区
2144171K->2129287K(2146304K), 10.4200280 sec     old区情况
3514052K->2129287K(4023680K)                     heap区情况
119979K->118652K(190132K)], 26.2193500 secs      perm区情况 
[Times: user=30.35 sys=5.19, real=26.22 secs]    整个过程的时间消耗
 
2、一段正常的CMS的日志
2013-11-27T04:00:12.819+0800: 38892.743: [GC [1 CMS-initial-mark: 1547313K(2146304K)] 1734957K(4023680K), 0.1390860 secs] [Times: user=0.14 sys=0.00, real=0.14 secs]
2013-11-27T04:00:12.958+0800: 38892.883: [CMS-concurrent-mark-start]
2013-11-27T04:00:19.231+0800: 38899.155: [CMS-concurrent-mark: 6.255/6.272 secs] [Times: user=8.49 sys=1.57, real=6.27 secs]
2013-11-27T04:00:19.231+0800: 38899.155: [CMS-concurrent-preclean-start]
2013-11-27T04:00:19.250+0800: 38899.175: [CMS-concurrent-preclean: 0.018/0.019 secs] [Times: user=0.02 sys=0.00, real=0.02 secs]
2013-11-27T04:00:19.250+0800: 38899.175: [CMS-concurrent-abortable-preclean-start]
 CMS: abort preclean due to time 2013-11-27T04:00:25.252+0800: 38905.176: [CMS-concurrent-abortable-preclean: 5.993/6.002 secs] [Times: user=6.97 sys=2.16, real=6.00 secs]
2013-11-27T04:00:25.253+0800: 38905.177: [GC[YG occupancy: 573705 K (1877376 K)]38905.177: [Rescan (parallel) , 0.3685690 secs]38905.546: [weak refs processing, 0.0024100 secs]38905.548: [cla
ss unloading, 0.0177600 secs]38905.566: [scrub symbol & string tables, 0.0154090 secs] [1 CMS-remark: 1547313K(2146304K)] 2121018K(4023680K), 0.4229380 secs] [Times: user=1.41 sys=0.01, real=
0.43 secs]
2013-11-27T04:00:25.676+0800: 38905.601: [CMS-concurrent-sweep-start]
2013-11-27T04:00:26.436+0800: 38906.360: [CMS-concurrent-sweep: 0.759/0.760 secs] [Times: user=1.06 sys=0.48, real=0.76 secs]
2013-11-27T04:00:26.436+0800: 38906.360: [CMS-concurrent-reset-start]
2013-11-27T04:00:26.441+0800: 38906.365: [CMS-concurrent-reset: 0.005/0.005 secs] [Times: user=0.00 sys=0.00, real=0.00 secs]
这个是一个正常的CMS的日志，共分为七个步骤，重点关注initial-mark和remark这两个阶段，因为这两个是停机的。
A、[GC [1 CMS-initial-mark: 1547313K(2146304K)] 1734957K(4023680K), 0.1390860 secs] [Times: user=0.14 sys=0.00, real=0.14 secs]
各个数据依次表示标记前后old区的所有对象占内存大小和old的capacity，整个JavaHeap（不包括perm）所有对象占内存总的大小和JavaHeap的capacity。
B、2013-11-27T04:00:25.253+0800: 38905.177: [GC[YG occupancy: 573705 K (1877376 K)]38905.177: [Rescan (parallel) , 0.3685690 secs]38905.546: [weak refs processing, 0.0024100 secs]38905.548: [class unloading, 0.0177600 secs]38905.566: [scrub symbol & string tables, 0.0154090 secs] [1 CMS-remark: 1547313K(2146304K)] 2121018K(4023680K), 0.4229380 secs] [Times: user=1.41 sys=0.01, real=0.43 secs]
Rescan (parallel)表示的是多线程处理young区和多线程扫描old+perm的卡表的总时间， parallel 表示多GC线程并行。
weak refs processing 处理old区的弱引用的总时间，用于回收native memory。
class unloading 回收SystemDictionary消耗的总时间。
 
3、一段正常的Young GC的日志
2013-11-27T04:00:07.345+0800: 38887.270: [GC 38887.270: [ParNew: 1791076K->170624K(1877376K), 0.2324440 secs] 2988366K->1413629K(4023680K), 0.2326470 secs] [Times: user=0.80 sys=0.00, real=0.
23 secs]
ParNew这个表明是并行的回收方式，具体的分别是young区、整个heap区的情况；
 
4、一段通过system.gc产生的FullGC日志
2013-07-21T17:44:01.554+0800: 50.568: [Full GC (System) 50.568: [CMS: 943772K->220K(2596864K), 2.3424070 secs] 1477000K->220K(4061184K), [CMS Perm : 3361K->3361K(98304K)], 2.3425410 secs] [Times: user=2.33 sys=0.01, real=2.34 secs]
解释如下：
Full GC (System)意味着这是个system.gc调用产生的MSC。
“943772K->220K(2596864K), 2.3424070 secs”表示：这次MSC前后old区内总对象大小，old的capacity及这次MSC耗时。
“1477000K->220K(4061184K)”表示：这次MSC前后JavaHeap内总对象大小，JavaHeap的capacity。
“3361K->3361K(98304K)], 2.3425410 secs”表示：这次MSC前后Perm区内总对象大小，Perm区的capacity。
 
5、一个特殊的GC日志，根据动态计算直接进行的FullGC（MSC的方式）
1
2013-03-13T13:48:06.349+0800: 7.092: [GC 7.092: [ParNew: 471872K->471872K(471872K), 0.0000420 secs]7.092: [CMS: 366666K->524287K(524288K), 27.0023450 secs] 838538K->829914K(996160K), [CMS Perm : 3196K->3195K(131072K)], 27.0025170 secs]
ParNew的时间特别短，jvm在minor gc前会首先确认old是不是足够大，如果不够大，这次young gc直接返回，进行MSC。


引用计数法不能解决循环引用问题
堆操作（如删除对象）的成本并不小，集中回收总体效率更高
绝大多数场合机器有相当多的idle time，正好适合GC运行

快排那几个
你说我需要突出在国美做的搜索相关的项目嘛
还有大文件切分为小文件进行排序的

1. 各节点的一致性问题：其默认的机制是通过多播机制，同步元数据信息，但是在比较繁忙的集群中，可能会由于网络的阻塞，或者节点处理能力达到饱和导致各节点元数据不一致——也就是所谓的脑裂问题，这样会使集群处于不一致状态。目前并没有一个彻底的解决方案来解决这个问题，但是可以通过将工作节点与元数据节点分开的部署方案来缓解这种情况。
	
2，大文件排序问题
一个24G的TXT文件。每行一个INT.MAX（2147483647?）的随机整数。做排序。运行环境是一台8G的MAC。要求用纯JDK，不能借助第三方包。
	
3，spring 事务管理。

使用堆栈（Stack）来模拟队列（FIFO）功能，要求数据必须存储在堆栈内部。需要实现enqueue（入队），dequeue（出对），isEmpty（判空）三个功能，并给出单元测试。

(1)首先一千万条查询记录，每条字符串长0~255，而限制内存<

1G，所以不能把一千万条记录全部放进内存中处理，经计算，1千万条记录的最大占用空间大小为256Byte*10^8=0.25KB *

10^8=2.5*10^7KB，而1G = 1024M = 1024*1024KB =

1.024*1.024*10^6KB，从这可看出内存一次性读取的最大记录数是40万条，所以使用hash分割将1千万条记录分成25个记录块，Hash(字符串记录)%25，使得相同的字符串记录在相同的记录块中，再使用哈希表来计算出40万条记录重复次数最大的前10条记录，哈希表的key是记录字符串，值是重复次数。这样25次访问完1千万条记录，将会得到250条记录，然后使用Map存储这250条记录，key是重复次数，值是记录字符串，比较函数是greater函数对象，从大到小存储在Map中，前10条即是最热门的10条查询串。

(2)复杂度分析：2N + klogk ～ O(N)。但是有个问题是，假如有些查询记录重复次数大于40万次，则还有可能相同记录不在同一个记录块中的情况，还是会有问题，希望大神能给出好的想法。


再写一个程序，判断单链表中是否有环
TCP和UDP的区别；
TCP如何保证可靠传输；
HTTP的报文格式；
HTTP（请求和回复）的头部包含哪些内容；
cookie是在头部还是数据段，为什么；
HTTP回复的状态码你知道哪些

然后是Java面向对象：
说说多态的理解：我说了重载和重写，但他说要说多态是什么，我一直以为多态就是指重载和重写...
Java的设计模式：问我什么事装饰模式（还是门面模式记不起了），我说只知道工厂模式和单例模式；
问单例模式的实现；
也问了Java多线程的实现及同步；

操作系统：
问进程和线程的区别；
问操作系统如何实现多进程的调度；
	先进先出，短进程优先，轮转法，多级反馈队列
软件工程：
问开发的瀑布模型；
问开发软件项目的历程；
问系统设计和详细设计的区别；类图是在哪个阶段画的；
java
1.final finally finalize的区别
2.list  set  queue
3.stringbuffer stringbuider
4.继承 
5.线程 这个问的挺细的，还让我写个生产者消费者的问题
	http://blog.csdn.net/monkey_d_meng/article/details/6251879
利用内存映射加载信息，再利用创建字典树的方法进行统计
寻找热门查询： 搜索引擎会通过日志文件把用户每次检索使用的所有检索串都记录下来，每个查询串 的长度为1-255字节。假设目前有一千万个记录， 这些查询串的重复度比较高，虽然总数是1千万，但如果除去重复后，不超过3百万个 。一个查询串的重复度越高，说明查询它的用户越多， 也就是越热门。请你统计最热门的10个查询串，要求使用的内存不能超过1G。 （1）请描述你解决这个问题的思路； （2）请给出主要的处理流程，算法，以及算法的复杂度。

由于重复度比较高，300万*255字节 = 765M，不会超过1G，因此可以用Hash_Map的思路。通过

哈希函数将字符串映射到Hash空间中，哈希模型的Key值为字符串，value值为字符串的出现次数count。之后维护一个k =

10的小根堆，这样能保证在logK的时间内查找和删除元素，因此总体的时间复杂度是O(n) + O(nlogk)

Serial(串行GC)收集器
Serial收集器是一个新生代收集器，单线程执行，使用复制算法。它在进行垃圾收集时，必须暂停其他所有的工作线程(用户线程)。是Jvm client模式下默认的新生代收集器。对于限定单个CPU的环境来说，Serial收集器由于没有线程交互的开销，专心做垃圾收集自然可以获得最高的单线程收集效率。
ParNew(并行GC)收集器
ParNew收集器其实就是serial收集器的多线程版本，除了使用多条线程进行垃圾收集之外，其余行为与Serial收集器一样。
Parallel Scavenge(并行回收GC)收集器
Parallel Scavenge收集器也是一个新生代收集器，它也是使用复制算法的收集器，又是并行多线程收集器。parallel Scavenge收集器的特点是它的关注点与其他收集器不同，CMS等收集器的关注点是尽可能地缩短垃圾收集时用户线程的停顿时间，而parallel Scavenge收集器的目标则是达到一个可控制的吞吐量。吞吐量= 程序运行时间/(程序运行时间 + 垃圾收集时间)，虚拟机总共运行了100分钟。其中垃圾收集花掉1分钟，那吞吐量就是99%。
Serial Old(串行GC)收集器
Serial Old是Serial收集器的老年代版本，它同样使用一个单线程执行收集，使用“标记-整理”算法。主要使用在Client模式下的虚拟机。
Parallel Old(并行GC)收集器
Parallel Old是Parallel Scavenge收集器的老年代版本，使用多线程和“标记-整理”算法。
CMS(并发GC)收集器
CMS(Concurrent Mark Sweep)收集器是一种以获取最短回收停顿时间为目标的收集器。CMS收集器是基于“标记-清除”算法实现的，整个收集过程大致分为4个步骤：
①.初始标记(CMS initial mark)
②.并发标记(CMS concurrenr mark)
③.重新标记(CMS remark)
④.并发清除(CMS concurrent sweep)
     其中初始标记、重新标记这两个步骤任然需要停顿其他用户线程。初始标记仅仅只是标记出GC ROOTS能直接关联到的对象，速度很快，并发标记阶段是进行GC ROOTS 根搜索算法阶段，会判定对象是否存活。而重新标记阶段则是为了修正并发标记期间，因用户程序继续运行而导致标记产生变动的那一部分对象的标记记录，这个阶段的停顿时间会被初始标记阶段稍长，但比并发标记阶段要短。
     由于整个过程中耗时最长的并发标记和并发清除过程中，收集器线程都可以与用户线程一起工作，所以整体来说，CMS收集器的内存回收过程是与用户线程一起并发执行的。
CMS收集器的优点：并发收集、低停顿，但是CMS还远远达不到完美，器主要有三个显著缺点：
CMS收集器对CPU资源非常敏感。在并发阶段，虽然不会导致用户线程停顿，但是会占用CPU资源而导致引用程序变慢，总吞吐量下降。CMS默认启动的回收线程数是：(CPU数量+3) / 4。
CMS收集器无法处理浮动垃圾，可能出现“Concurrent Mode Failure“，失败后而导致另一次Full  GC的产生。由于CMS并发清理阶段用户线程还在运行，伴随程序的运行自热会有新的垃圾不断产生，这一部分垃圾出现在标记过程之后，CMS无法在本次收集中处理它们，只好留待下一次GC时将其清理掉。这一部分垃圾称为“浮动垃圾”。也是由于在垃圾收集阶段用户线程还需要运行，
即需要预留足够的内存空间给用户线程使用，因此CMS收集器不能像其他收集器那样等到老年代几乎完全被填满了再进行收集，需要预留一部分内存空间提供并发收集时的程序运作使用。在默认设置下，CMS收集器在老年代使用了68%的空间时就会被激活，也可以通过参数-XX:CMSInitiatingOccupancyFraction的值来提供触发百分比，以降低内存回收次数提高性能。要是CMS运行期间预留的内存无法满足程序其他线程需要，就会出现“Concurrent Mode Failure”失败，这时候虚拟机将启动后备预案：临时启用Serial Old收集器来重新进行老年代的垃圾收集，这样停顿时间就很长了。所以说参数-XX:CMSInitiatingOccupancyFraction设置的过高将会很容易导致“Concurrent Mode Failure”失败，性能反而降低。
最后一个缺点，CMS是基于“标记-清除”算法实现的收集器，使用“标记-清除”算法收集后，会产生大量碎片。空间碎片太多时，将会给对象分配带来很多麻烦，比如说大对象，内存空间找不到连续的空间来分配不得不提前触发一次Full  GC。为了解决这个问题，CMS收集器提供了一个-XX:UseCMSCompactAtFullCollection开关参数，用于在Full  GC之后增加一个碎片整理过程，还可通过-XX:CMSFullGCBeforeCompaction参数设置执行多少次不压缩的Full  GC之后，跟着来一次碎片整理过程。
G1收集器
G1(Garbage First)收集器是JDK1.7提供的一个新收集器，G1收集器基于“标记-整理”算法实现，也就是说不会产生内存碎片。还有一个特点之前的收集器进行收集的范围都是整个新生代或老年代，而G1将整个Java堆(包括新生代，老年代)。

一个好的程序员除了要实现系统必须的功能模块，如何做到让自己的系统跑的更快？如果提供更好的用户体验？如何提升系统吞吐量，最大限度的节约服务器资源，节约成本？同样成为必不可少的生存技能。日常的java开发提升性能的方式和途径非常多样化，无论是从语言层面、设计层面还是架构层面都有许多可以讨论的话题。在这样一个既有深度又有广度的话题下，让我们一起探讨怎么样找到系统最大的那块短板，并且如何采用最合适的方式进行优化！

一个较大型java服务端系统，交易用时较长，但系统cpu、内存等资源使用并不高，怎样能知道系统用时的主要瓶颈在哪？

cpu、内容都不高的话，往往可能是调用的下游系统响应比较慢，或者自身应用当中有临界资源(比如锁），或者系统里有大量的线程处于sleep或者wait状态，或者网络和磁盘的访问是瓶颈。排查的话，最后能够进行一次单台机器的压测，先压到系统的极限能力，先观察网络和磁盘是否都正常，然后jstack看下线程都在干啥（是否有大量的线程wait或者sleep在同一个位置，有的话这里就是瓶颈），同时关注所有下游依赖的调用耗时（是否下游依赖非常慢）。诊断到具体的原因后再对症下药，药到病除。
29

java开发中如何使用Redis提高性能？

Redis提升性能通常可以代表一类提升性能的方式：缓存。缓存在性能提升上是一个很好的武器，无论是前端页面还是后端数据等场景都可以通过采用缓存的方式来大大提升性能，缓存在性能提升的效果上往往是立竿见影的。对于如何使用缓存，什么样的数据适合缓存需要有一个判断，往往缓存的数据需要满足多读少写的特性，也就是不会经常更新（或者能接受过期数据），如果更新得非常频繁，缓存的价值就会大打折扣了。此外，缓存稍微会带来一些额外的复杂性以及在排查问题上带来一些干扰因素也是需要考虑的。
13

客户端到Nginx和Nginx代理到后端java应用什么场景更加适合开启长连接，对于提供的接口如何在更好的实现API的降级和流控呢？思路是？

从客户端到nginx什么时候用长连接：这个得看客户端是否会在短时间内发起多次请求，拿淘宝交易来说，用户要买一个东西需要先浏览商品，浏览商品一般会货比三家，短时间内会发起多次商品浏览的请求，所以商品详情这个系统的客户端到nginx可以采用长连接或者keepalive；浏览完商品后，用户要购买，用户浏览了20个商品可能最终只购买一个，所以购买这个系统就没有太多必要采用长连接了。长连接的好处是能对多频次的请求提升性能，节约资源；但是长连接的状态系统也是需要花费资源去维护的，所以这里会有个平衡。
从nginx到java后端：这个层面最好都还是采用长连接比较好，upstream的长连接还是能带来比较大的性能提升,Nginx从 1.1.4 开始，实现了对后端机器http, fastcgi, memcache等协议的长连接支持，这一特性也大大降级了系统的负载。
api的降级和流控：降级和流控可以做到web服务器层（比如nginx），也可以做到应用层（比如java程序中），降级和限流最核心的概念包含：资源（你要保护什么？）、状态统计（对资源使用情况的监控）、规则与策略（到达某个场景时做什么操作）。在阿里，应用端我们有专门的框架sentinel，web服务器端我们有自己开发的nginx模块。流控和降级对保障系统的稳定性尤为重要。
7

如何有效的跟踪JVM中线程总数及各线程所占资源?

获取jvm线程数的方法比较多。1、jvm自带的工具jconsole和virtualvm等都能看到； 2、jstack pid能看到每一个线程的状态，自然也是能统计线程数的；3、还有一个我常用的，在linux下我会用ps -Lf pid|wc 去看下进程下的线程数。
线程所占的资源这个不太好衡量了，cpu、内存等资源都是共享的，可以通过看jstack看线程的运行状态来看它是否占据着cpu，堆内存的话是共享的，跟线程本身关系不大，此外可以通过-Xss来线程栈的大小限制。
7

什么时候用接口，什么时候用抽象

接口与抽象类的选择有时候会不太好选择，但是这个的选择大部分时候都并没有那么重要，可以给一些建议：
1. 抽象类跟普通的类比就是可以实现一些方法逻辑，而有个别方法可以不实现，让子类实现。
2. 接口只能定义方法，不能有任何实现，所以如果要有逻辑实现，而部分方法需要子类实现可以用抽象类。
3. java不支持多继承，但可以实现多个接口，所以在继承环境中，如果考虑到多继承需要用接口。
7

请分享一下你成长为资深专家的历程与成功的秘诀

“不积跬步无以至千里，不积小流无以成江海”平时多积累，多总结，多思考。技术领域的深度和广度远远大于我们的认知，一点一点进步。
5

java的垃圾回收机制，采用的是roottrance来判断对象是否是垃圾的，这个对象的多层引用是怎么判断的呢？能否说一下回收原理和垃圾对象的判断?

gc的root主要包含：
Java虚拟机栈中变量所引用的对象（大部分）
方法区中静态属性引用的对象
方法区中常量引用的对象
JNI Native方法引用的对象
如果是多层引用的话会一级一级往下找，从root对象往下找，能到达的都是属于不能被gc的对象，这个找的过程就好比一个染色，如果下一个对象已经被染色了，则不再往下递归。
5

对于KV存储，如当有百万级+的数据，为提高性能，采用主动刷新到缓存（永久生效）。当数据量翻倍后占用存储空间也更大。如何设计读数据接口稳定性(如缓存机故障数据丢失）？如何存储热点数据？

1、缓存机故障数据丢失
从实践上来说，缓存系统需要是一个集群而不是单机。如果要做到预防局部故障导致缓存数据丢失，需要从实际的场景中来探讨方案：
假设你的系统几乎不能容忍缓存数据的丢失，那缓存的数据是需要存多份的。如果完全不能容忍缓存数据丢失，是需要做同步多写的，这样代价比较大。通常的场景一般我们能接受少量的丢失，这样的话可以做异步的master数据同步slave结构，
为了提升缓存系统的性能和资源利用率，一般需要将缓存分区，每一个区可以有1个maser节点和2个slave节点，不同区的master和slave节点均匀散布在缓存集群的机器上面，如果一台机器挂了，这台机器的master则切到它的一个slave上面。对于缓存的读写操作，可以完全在master上进行（架构简单，master和salve混布后，资源利用率也挺高的）；或者写master，读slave都可以（架构稍复杂）。
2、存储热点
对于热点数据建议在应用的机器本身再加一级缓存，这个缓存可以直接在程序里面（耗费内存空间不大的话）LRU算法更新，也可以放堆外内存（避免gc）
5
